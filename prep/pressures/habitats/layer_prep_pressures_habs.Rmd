---
title: "OHIBC Pressures habitat layer preparation"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ohibc/src/templates/ohibc_hdr1.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}
library(sp)        # the classes and methods that make up spatial ops in R
library(rgdal)
library(maptools)
library(raster)
library(DT)

dir_git <- '~/github/ohibc'
dir_rgn <- file.path(dir_git, 'prep/regions')  ### github: general buffer region shapefiles
  
source(file.path(dir_git, 'src/R/common.R'))  ### an OHIBC specific version of common.R

### goal specific folders and info
dir_hab  <- file.path(dir_git, 'prep/pressures/habitats')
scenario <- 'v2016'
dir_anx  <- file.path(dir_neptune_data, 'git-annex/bcprep')
#dir_rast <- file.path(dir_anx, 'pressures/habitats')
dir_rast <- file.path(dir_hab, 'raster')

### provenance tracking
# source('~/github/ohibc/src/R/prov.R')
#   ### Provenance tracking functions: must source at start to initialize prov_track
# dir_prov <- file.path(dir_hab, 'prov')
#   ### set a provenance folder for this script
# this_script_file <- file.path(dir_hab, 'layer_prep_pressures_habs.Rmd')
#   ### can't recognize the current script name on its own :(
# prov_run_tag <- 'standard run'

### goal-specific source scripts
# source(file.path(dir_spp, 'R/spp_fxn.R'))
# git_prov(file.path(dir_spp, 'R/spp_fxn.R'), type = 'sourced_script')

### set up CRS for BC Albers based on proj4string.
p4s_bcalb <- CRS('+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0')

```

``` {r raster plot function, echo = FALSE}
plot_raster <- function(rast,
                            title = '', scale_label = '',
                            scale_limits = c(0, max(values(rast), na.rm = TRUE)),
                            rev_scale = FALSE) {
  require(ggplot2)
  require(RColorBrewer)
  require(maptools)

  rast_pts <- raster::rasterToPoints(rast) %>%
    as.data.frame()
  names(rast_pts) <- c('x', 'y', 'layer')
  rast_pts <- rast_pts %>%
    mutate(group = 1) ### need 'group' variable to plot below...

  if(rev_scale == TRUE) {
    cols <- rev(colorRampPalette(brewer.pal(11, 'Spectral'))(255)) # rainbow color scheme, low = blue
  } else {
    cols <- colorRampPalette(brewer.pal(11, 'Spectral'))(255) # rainbow color scheme, low = red
  }

#   poly_rgn <- readShapePoly(fn = file.path(dir_rgn, 'ohibc_rgn'), proj4string = p4s_bcalb)
#   poly_rgn_df <- fortify(poly_rgn, region = 'rgn_id') %>%
#     rename(rgn_id = id, x = long, y = lat) %>%
#     mutate(rgn_id = as.integer(rgn_id))

  poly_land <- readShapePoly(fn = file.path(dir_rgn, 'ohibc_land'), proj4string = p4s_bcalb)
  poly_land_df <- fortify(poly_land) %>%
    rename(x = long, y = lat)
  
  x <- c(159000, 1237700, 174000, 1223000) # from extent of poly_rgn; just hard code it.

  rast_plot <- ggplot(data = rast_pts, aes(x = x, y = y, group = group, fill = layer)) +
    ### omit ticks, axis text:
    theme(axis.ticks = element_blank(), axis.text = element_blank()) +
    ### set text style, title size and position, and legend position:
    theme(text = element_text(family = 'Helvetica', color = 'gray30', size = 12),
          plot.title = element_text(size = rel(1.5), hjust = 0, face = 'bold'),
          legend.position = 'right') +
    ### Blank background and grid:
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank()) +
    scale_fill_gradientn(colours = cols, na.value = 'gray80',
                        limits = scale_limits) +
    geom_raster(alpha = .8) +
    geom_polygon(data = poly_land_df, color = 'gray70', fill = 'gray75', size = 0.1) +
    # geom_polygon(data = poly_rgn_df,  color = 'gray20', fill = NA,       size = 0.1) +
    coord_cartesian(xlim = c(x[1], x[2]), ylim = c(x[3], x[4]), expand = TRUE) +
    labs(title = title,
         fill  = scale_label,
         x = NULL, y = NULL)

  print(rast_plot)
}

```

Assemble a habitat map for OHIBC pressures calculations.

Projection: BC Albers

Raster: 
* 500 m cell size - need to resolve 1 km features (e.g. intertidal buffer)

``` {r load_habitat_layers_list, echo = FALSE}

hab_lyrs <- read_csv(file.path(dir_hab, 'pressures_hab_layers.csv'))

# hab_dirs <- read_csv(file.path(dir_hab, 'bcmca_shps_all.csv'))
# 
# hab_lyrs <- hab_lyrs %>%
#   mutate(layer_name = paste(layer_name, '.shp', sep = '')) %>%
#   left_join(hab_dirs %>%
#               select(dir, layer_name = shp),
#             by = 'layer_name')
# 
# write_csv(hab_lyrs, file.path(dir_hab, 'pressures_hab_layers.csv'))

DT::datatable(hab_lyrs)

```

# Set up depth regions: coastal intertidal, shallow, shelf, slope, deep

Define shelf/slope/deep not by 60m/200m/2000m (per CHI 2015) but by:

* "deep" is bottom of continental slope - outline defined by shoremost boundary of Pacific Offshore region
* "shelf" is top of continental slope - all area less than 200 m, outside of Pacific Offshore region
* "slope" is region between shelf and slope

The steps:

* Create raster of benthic class layer.
* Create raster of intertidal layer
    * create a 1 km buffer around land (intertidal proxy)
    * rasterize land polygon and 1 km buffer polygon
    * subtract land from 1 km buffer to create intertidal
* create raster of deep/abyssal zone
    * use Pacific Offshore region - inland boundary is base of slope
    * rasterize PO polygon
* use benthic raster depth values, with deep and intertidal as boundaries

``` {r rasterize_benthic_class, echo = FALSE}
### Benthic Class is a commonly used layer for habitats - depth and substrate in particular.
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_benthic_class_file <- file.path(dir_rast, 'rast_benthic_class_atF.tif')

if(!file.exists(rast_benthic_class_file)) {
  message('Creating benthic_class raster: ', rast_benthic_class_file)
  
  library(gdalUtils)
  
  ### figure out source file location for polygon
  zone_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'BenthicClass'))
  zone_shp  <- file.path(dir_anx, 'data', zone_lyrs[1, ]$dir, paste(zone_lyrs[1, ]$layer_name, '.shp', sep = ''))

  ### rasterize the beast
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  library(gdalUtils)
  rast_benthic_class <- gdal_rasterize(src_datasource = zone_shp, 
                                 dst_filename   = rast_benthic_class_file,
                                 a = 'Marxan_ID', # attribute to burn
                                 a_nodata = NA,
                                 # at = TRUE,
                                 te = base_te,
                                 tr = raster::res(rast_base),
                                 output_Raster = FALSE)
  ### this saves an 80+ MB file; But raster::rasterize is really slow.
  
  remove(rast_benthic_class) # clear memory
  
} else {
  message(sprintf('Benthic_class raster already exists at: %s', rast_benthic_class_file))
}

  # writeRaster(rast_benthic_class, rast_benthic_class_file, overwrite = TRUE)

```

Setting up zone rasters.  Cells will be identified with values according to zone:

* 1 = intertidal
* 2 = coastal
* 3 = shelf
* 4 = slope
* 5 = deep/abyssal plane
* 6 = offshore
* NA = not in a zone

``` {r create_intertidal_zone_raster, echo = FALSE}

rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_zone_intertidal_file <- file.path(dir_rast, 'rast_zone_intertidal.tif')

if(!file.exists(rast_zone_intertidal_file)) {
  message(sprintf('Missing intertidal zone raster; creating new: %s', 
                  rast_zone_intertidal_file))

  poly_intertidal_file <- file.path(dir_rgn, 'ohibc_offshore_1km')
  if(!file.exists(paste(poly_intertidal_file, '.shp', sep = ''))) {
    ### create a polygon for 1 km offshore regions.
    poly_land <- readOGR(dsn = path.expand(dir_rgn), 
                         layer = 'ohibc_land', 
                         stringsAsFactors = FALSE) %>%
      createSPComment(which = NULL, overwrite = TRUE)
	
    poly_buffer <- raster::buffer(poly_land, width = 1000)

    poly_bc_rgn <- readOGR(dsn = path.expand(dir_rgn), 
                           layer = 'ohibc_rgn', 
                           stringsAsFactors = FALSE)
    poly_intertidal <- raster::intersect(poly_buffer, poly_bc_rgn)
    
    writePolyShape(poly_intertidal, poly_intertidal_file)
                                            
  } else {
    poly_intertidal <- readShapePoly(poly_intertidal_file,
                                     proj4string = p4s_bcalb)
  }
  
  ### Now we have an intertidal layer.  Rasterize it!
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_zone_intertidal <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_intertidal_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_zone_intertidal_file),
      a = 'rgn_id', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = raster::res(rast_base),
      output_Raster = TRUE
    )
  })

  ### code layers to be uniform zone ID
  values(rast_zone_intertidal)[!is.na(values(rast_zone_intertidal))] <- 1

  writeRaster(rast_zone_intertidal, rast_zone_intertidal_file, overwrite = TRUE)
  
  remove(rast_zone_intertidal) # clean up memory

} else {
  message(sprintf('Intertidal zone raster already exists: %s', 
          rast_zone_intertidal_file))
}

```

``` {r create_deep_zone_raster, echo = FALSE}
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_zone_deep_file <- file.path(dir_rast, 'rast_zone_deep.tif')

if(!file.exists(rast_zone_deep_file)) {
  message('Missing deep zone raster; creating new file: ', rast_zone_deep_file)
  poly_bc_rgn     <- readShapePoly(file.path(dir_rgn, 'ohibc_rgn'),
                                   proj4string = p4s_bcalb)
  ### for deep zone, filter out all but the PO region
  poly_deep <- poly_bc_rgn[poly_bc_rgn@data$rgn_code == 'PO', ]
  poly_deep_file <- file.path(dir_rast, 'poly_deep')
  writePolyShape(poly_deep, poly_deep_file)
  
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_zone_deep <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_deep_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_zone_deep_file),
      a = 'rgn_id', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = raster::res(rast_base),
      output_Raster = TRUE
    )
  })
  
  ### code layers to be uniform zone ID
  values(rast_zone_deep)[!is.na(values(rast_zone_deep))] <- 5

  writeRaster(rast_zone_deep, rast_zone_deep_file, overwrite = TRUE)
  
  remove(rast_zone_deep) # clean up memory

} else {
  message(sprintf('Deep zone raster already exists at: %s', 
          rast_zone_deep_file))
}

```

``` {r create_depth_rasters, echo = FALSE}

rast_zone_coastal_file <- file.path(dir_rast, 'rast_zone_coastal.tif')
rast_zone_shelf_file <- file.path(dir_rast, 'rast_zone_shelf.tif')
rast_zone_slope_file <- file.path(dir_rast, 'rast_zone_slope.tif')
rast_zone_offshore_file <- file.path(dir_rast, 'rast_zone_offshore.tif')

if(any(!file.exists(c(rast_zone_coastal_file, 
                      rast_zone_shelf_file, 
                      rast_zone_slope_file, 
                      rast_zone_offshore_file)))) {
  ### Create each of these rasters based on benthic_class codes, and masking from
  ### deep and intertidal rasters created above.
  
  # * `benthic_class` will be divided to depth, substrate, and formation according to the rule for field `ID`:
  #     * 1000's = depth              * 10's = substrate          * 1's = BPI
  #         * 1000 <- 0 - 20 m            * 10 <- mud                 * 1 <- ridge
  #         * 2000 <- 20 - 50 m           * 20 <- sand                * 2 <- depression
  #         * 3000 <- 50 - 200 m          * 30 <- hard                * 3 <- flat
  #         * 4000 <- 200 m +             * 90 <- unknown             * 4 <- slope
  
  rast_depthzone <- floor(rast_benthic_class/1000) 
  
  ### initialize zonal rasters to base_raster
  rast_zone_coastal <- rast_zone_shelf <- rast_zone_slope <- rast_zone_offshore <- rast_base
  
  ### rast_zone_coastal includes cells 50 m or shallower, excluding intertidal.
  values(rast_zone_coastal)[values(rast_depthzone) %in% c(1, 2)] <- 2
  values(rast_zone_coastal)[!is.na(values(rast_zone_intertidal))] <- NA
  
  ### rast_zone_shelf includes cells between 50 and 200 m, excluding intertidal and
  ### Pacific Offshore (deep)
  values(rast_zone_shelf)[values(rast_depthzone) == 3] <- 3
  values(rast_zone_shelf)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_shelf)[!is.na(values(rast_zone_deep))]       <- NA
  
  ### rast_zone_slope includes cells deeper than 200 m, excluding the Pacific Offshore
  ### region (abyssal plain) and any intertidal that somehow gets in the way
  values(rast_zone_slope)[values(rast_depthzone) == 4] <- 4
  values(rast_zone_slope)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_slope)[!is.na(values(rast_zone_deep))]       <- NA

  ### rast_zone_offshore is *all* deeper than 50 m, excluding any intertidal
  values(rast_zone_offshore)[values(rast_depthzone) %in% c(2, 3, 4)] <- 6
  values(rast_zone_offshore)[!is.na(values(rast_zone_intertidal))] <- NA

  writeRaster(rast_zone_coastal,  rast_zone_coastal_file,  overwrite = TRUE)
  writeRaster(rast_zone_shelf,    rast_zone_shelf_file,    overwrite = TRUE)
  writeRaster(rast_zone_slope,    rast_zone_slope_file,    overwrite = TRUE)
  writeRaster(rast_zone_offshore, rast_zone_offshore_file, overwrite = TRUE)

  remove(rast_zone_coastal, rast_zone_shelf, rast_zone_slope, rast_zone_offshore) # clean up memory

} else {
  message('Coastal, shelf, slope, and offshore zone rasters already exist:')
  message(sprintf('  %s \n  %s \n  %s \n  %s', 
          rast_zone_coastal_file, rast_zone_shelf_file, rast_zone_slope_file, rast_zone_offshore_file))
#   rast_zone_coastal  <- raster(rast_zone_coastal_file)
#   rast_zone_shelf    <- raster(rast_zone_shelf_file)
#   rast_zone_slope    <- raster(rast_zone_slope_file)
#   rast_zone_offshore <- raster(rast_zone_offshore_file)
}

```


``` {r create_benth_type_raster, echo = FALSE}

rast_benth_type_file <- file.path(dir_rast, 'rast_benth_type.tif')
rast_benthic_class <- raster(rast_benthic_class_file)

if(!file.exists(rast_benth_type_file)) {
  ### Create a raster with substrate type based on benthic_class codes
  
  # * `benthic_class` will be divided to depth, substrate, and formation according to the rule for field `ID`:
  #     * 1000's = depth              * 10's = substrate          * 1's = BPI
  #         * 1000 <- 0 - 20 m            * 10 <- mud                 * 1 <- ridge
  #         * 2000 <- 20 - 50 m           * 20 <- sand                * 2 <- depression
  #         * 3000 <- 50 - 200 m          * 30 <- hard                * 3 <- flat
  #         * 4000 <- 200 m +             * 90 <- unknown             * 4 <- slope
  
  rast_benth_type <- rast_benthic_class - round(rast_benthic_class, -3)
  rast_benth_type <- floor(rast_benth_type/10) 
  
  writeRaster(rast_benth_type, rast_benth_type_file, overwrite = TRUE)

  remove(rast_benth_type, rast_benthic_class) # clean up memory

} else {
  message('Benthic type raster already exists:', rast_benth_type_file)
}

```


``` {r rasterize_coastal_class, echo = FALSE}
### Set up coastal_classes raster:
### * buffer the lines - add extra width to avoid holes
### * rasterize, then mask with intertidal zone
### * translate codes to coastal class only, and save
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_coastal_class_file <- file.path(dir_rast, 'rast_coastal_class.tif')

if(!file.exists(rast_coastal_class_file)) {
  message('No coastal class raster found at: ', rast_coastal_class_file)
  
  poly_coastal_class_file <- file.path(dir_rast, 'poly_coastal_class')
  if(!file.exists(paste(poly_coastal_class_file, '.shp', sep = ''))) {
    coastal_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'CoastalClass'))
    coastal_shp_file <- file.path(dir_anx, 'data', coastal_lyrs[1, ]$dir, 
                                  paste(coastal_lyrs[1, ]$layer_name, '.shp', sep = ''))
    line_coastal <- readShapeLines(coastal_shp_file, proj4string = p4s_bcalb)
    ptc <- proc.time()
    poly_coastal <- gBuffer(line_coastal, 
                            byid = TRUE,
                            width = 2000,
                            capStyle = 'FLAT')
    proc.time() - ptc # 609 seconds for full shapefile
    writePolyShape(poly_coastal, poly_coastal_class_file)
  } else {
    poly_coastal <- readShapePoly(poly_coastal_class_file, 
                                  proj4string = p4s_bcalb)
  }
  
  ### Now to create the raster... 
  
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_coastal_class <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_coastal_class_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_coastal_class_file),
      a = 'ID', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = raster::res(rast_base),
      output_Raster = TRUE
    )
  })

  ### now clip coastal zone raster to only intertidal
  values(rast_coastal_class)[is.na(values(rast_zone_intertidal))] <- NA

  ### Now to break down the coastal classes by type.
  # * `coastalclasses` will be determined according to the rule from field `ID`:
  #     * Initial digit (2) is unused?; delete
  #     * Next two digits (0 - 34) denote the coastal class according to
  #         http://alaskafisheries.noaa.gov/mapping/DataDictionary/Common/ShoreType.htm
  #     * final one or two digits represents geographic region; delete
  
  ### First, ditch trailing digit for five-digit values (two-digit regions)
  values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                             values(rast_coastal_class) > 10000] <- 
    floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                                     values(rast_coastal_class) > 10000]/10)
  ### Then, ditch trailing digit for all values
  values(rast_coastal_class)[!is.na(values(rast_coastal_class))] <- 
    floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class))]/10)
  ### Then, subtract 200 to ditch the leading value
  rast_coastal_class <- rast_coastal_class - 200

  writeRaster(rast_coastal_class, rast_coastal_class_file, overwrite = TRUE)
  
  remove(rast_coastal_class) # clean up memory

} else {
  message('Coastal class raster already exists: ', rast_coastal_class_file)
}

```


``` {r rasterize_layers_function, echo = FALSE}
  
rasterize_layers <- function(tmp_hab_lyrs) {
  
  ### Set up temp directory to store rasters; we'll save the completed raster then get rid of these.
  dir_tmp <- file.path(dir_rast, 'tmp')
  dir.create(dir_tmp, showWarnings = FALSE)
  
  for (i in 1:nrow(tmp_hab_lyrs)) { # i = 1
    message('Reading layer: ', tmp_hab_lyrs$layer_name[i])
    tmp_shp <- readOGR(dsn   = file.path(dir_anx, 'data', tmp_hab_lyrs$dir[i]),
                                 layer = tmp_hab_lyrs$layer_name[i], 
                                 stringsAsFactors = FALSE)
    ### create a buffer around points and lines
    if(tmp_hab_lyrs$layer_type[i] %in% c('line', 'point')) {
      message(sprintf('Buffering a %s layer: %s', 
                      tmp_hab_lyrs$layer_type[i], tmp_hab_lyrs$layer_name[i]))
      system.time({
        tmp_poly <- rgeos::gBuffer(tmp_shp, 
                                   byid     = TRUE,
                                   width    = tmp_hab_lyrs$buffer_m[i],
                                   capStyle = ifelse(tmp_hab_lyrs$layer_type[i] == 'line', 'FLAT', 'ROUND'))
      })
    } else {
      tmp_poly <- tmp_shp ### shp is already a polygon...
    }
    ### If no ID field, add one and populate it
    tmp_poly@data$raster_id <- c(1:nrow(tmp_poly@data))
    ### write poly to a temp file for the gdal_rasterize to access.
    writePolyShape(tmp_poly, file.path(dir_tmp, sprintf('tmp_poly%s', i)))
  }
  
  
  tmp_rast_list <- list() ### initialize empty list to store rasters
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  base_tr <- raster::res(rast_base)
  
  for (i in 1:nrow(tmp_hab_lyrs)) { # i = 1
    src_file <- path.expand(file.path(dir_tmp, sprintf('tmp_poly%s.shp', i)))
    dst_file <- path.expand(file.path(dir_tmp, sprintf('tmp_rast%s.tif', i)))
    src_dbf <- foreign::read.dbf(file.path(dir_tmp, sprintf('tmp_poly%s.dbf', i)))
    a <- names(src_dbf)
    a <- ifelse('raster_id' %in% a, 'raster_id', a[1])

    message(sprintf('Rasterizing temporary polygon %s of %s\n  src  = %s \n  dest = %s\n  attr = %s, class = %s',
                    i, nrow(tmp_hab_lyrs), src_file, dst_file, a, class(src_dbf[[a]])))
    ### save a temp raster since gdal_rasterize seems to hate creating new files?
    # writeRaster(rast_base, path.expand(file.path(dir_tmp, sprintf('tmp_rast%s.tif', i))), overwrite = TRUE)
    system.time({
      tmp_rast_list[[i]] <- gdalUtils::gdal_rasterize(
        src_datasource = src_file, 
        dst_filename   = dst_file,
        a = 'ID', # attribute to burn
        a_nodata = NA,
        # at = TRUE,
        te = base_te,
        tr = base_tr,
        output_Raster = TRUE
      )
    })
  }
  
  names(tmp_rast_list) <- tmp_hab_lyrs$layer_name
  
  unlink(dir_tmp) ### ditch the temp directory
  
  return(tmp_rast_list) ### A list object of temporary rasters
}
```

``` {r create_rocky_intertidal_raster, echo = FALSE}
rast_rocky_intertidal_file <- file.path(dir_rast, 'rast_rocky_intertidal.tif')

if(!file.exists(rast_rocky_intertidal_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  rocky_int_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'rocky intertidal' & load_layer == TRUE)

  rocky_int_rast_list <- rasterize_layers(rocky_int_hab_lyrs)

  message('Adding in coastal class layer')
  rast_coastal_class <- raster(rast_coastal_class_file) ### load coastal_class; need to filter to appropriate cells
  values(rast_coastal_class)[!values(rast_coastal_class) %in% c(1:10, 21:23)] <- NA
  
  ### then add to rocky_int_rast_list; then brick it, then sum it
  rocky_int_rast_list[[length(rocky_int_rast_list) + 1]] <- rast_coastal_class
  rocky_int_rast_brick <- stack(rocky_int_rast_list)
  rocky_int_rast_total <- sum(rocky_int_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(rocky_int_rast_total)[values(rocky_int_rast_total) == 0] <- NA
  values(rocky_int_rast_total)[!is.na(values(rocky_int_rast_total))] <- rocky_int_hab_lyrs$layer_id[1]
  
  ### clip to intertidal zone
  message('Clipping to intertidal zone raster')
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(rocky_int_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(rocky_int_rast_total)
  writeRaster(rocky_int_rast_total, rast_rocky_intertidal_file, overwrite = TRUE)
} else {
  message('Rocky intertidal zone raster already exists at: ', rast_rocky_intertidal_file)
}

```

``` {r create_beach_raster, echo = FALSE}
rast_beach_file <- file.path(dir_rast, 'rast_beach.tif')

if(!file.exists(rast_beach_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  beach_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'beach' & load_layer == TRUE)

  beach_rast_list <- rasterize_layers(beach_hab_lyrs)

  message('Adding in coastal class layer')
  ### Filter the coastal class layer to appropriate cells
  rast_coastal_class <- raster(rast_coastal_class_file) ### load coastal_class; need to filter to appropriate cells
  values(rast_coastal_class)[!values(rast_coastal_class) %in% c(11:20, 24:26)] <- NA
  
  ### then add to beach_rast_list; then brick it, then sum it
  beach_rast_list[[length(beach_rast_list) + 1]] <- rast_coastal_class
  beach_rast_brick <- stack(beach_rast_list)
  beach_rast_total <- sum(beach_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(beach_rast_total)[values(beach_rast_total) == 0] <- NA
  values(beach_rast_total)[!is.na(values(beach_rast_total))] <- beach_hab_lyrs$layer_id[1]
  
  ### clip to intertidal zone
  message('Clipping to intertidal zone raster')
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(beach_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(beach_rast_total)
  writeRaster(beach_rast_total, rast_beach_file, overwrite = TRUE)
} else {
  message('Beach zone raster already exists at: ', rast_beach_file)
}

```

``` {r create_mudflat_raster, echo = FALSE}
rast_mudflat_file <- file.path(dir_rast, 'rast_mudflat.tif')

if(!file.exists(rast_mudflat_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  mudflat_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'mud flats' & load_layer == TRUE)

  mudflat_rast_list <- rasterize_layers(mudflat_hab_lyrs)

  message('Adding in coastal class layer')
  ### Filter the coastal class layer to appropriate cells
  rast_coastal_class <- raster(rast_coastal_class_file) ### load coastal_class; need to filter to appropriate cells
  values(rast_coastal_class)[!values(rast_coastal_class) %in% c(11:20, 24:26)] <- NA
  
  ### then add to mudflat_rast_list; then brick it, then sum it
  mudflat_rast_list[[length(mudflat_rast_list) + 1]] <- rast_coastal_class
  mudflat_rast_brick <- stack(mudflat_rast_list)
  mudflat_rast_total <- sum(mudflat_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(mudflat_rast_total)[values(mudflat_rast_total) == 0] <- NA
  values(mudflat_rast_total)[!is.na(values(mudflat_rast_total))] <- mudflat_hab_lyrs$layer_id[1]
  
  ### clip to intertidal zone
  message('Clipping to intertidal zone raster')
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(mudflat_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(mudflat_rast_total)
  writeRaster(mudflat_rast_total, rast_mudflat_file, overwrite = TRUE)
} else {
  message('Mudflat zone raster already exists at: ', rast_mudflat_file)
}

```

``` {r create_saltmarsh_raster, echo = FALSE}
rast_saltmarsh_file <- file.path(dir_rast, 'rast_saltmarsh.tif')

if(!file.exists(rast_saltmarsh_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  saltmarsh_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'salt marsh' & load_layer == TRUE)

  saltmarsh_rast_list <- rasterize_layers(saltmarsh_hab_lyrs)

  saltmarsh_rast_brick <- stack(saltmarsh_rast_list)
  saltmarsh_rast_total <- sum(saltmarsh_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(saltmarsh_rast_total)[values(saltmarsh_rast_total) == 0] <- NA
  values(saltmarsh_rast_total)[!is.na(values(saltmarsh_rast_total))] <- saltmarsh_hab_lyrs$layer_id[1]
  
  ### clip to intertidal zone
  message('Clipping to intertidal zone raster')
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(saltmarsh_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(saltmarsh_rast_total)
  writeRaster(saltmarsh_rast_total, rast_saltmarsh_file, overwrite = TRUE)
} else {
  message('Saltmarsh zone raster already exists at: ', rast_saltmarsh_file)
}

```

``` {r create_surfgrass_raster, echo = FALSE}
rast_surfgrass_file <- file.path(dir_rast, 'rast_surfgrass.tif')

if(!file.exists(rast_surfgrass_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  surfgrass_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'surf grass' & load_layer == TRUE)

  surfgrass_rast_list <- rasterize_layers(surfgrass_hab_lyrs)

  surfgrass_rast_brick <- stack(surfgrass_rast_list)
  surfgrass_rast_total <- sum(surfgrass_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(surfgrass_rast_total)[values(surfgrass_rast_total) == 0] <- NA
  values(surfgrass_rast_total)[!is.na(values(surfgrass_rast_total))] <- surfgrass_hab_lyrs$layer_id[1]
  
  ### clip to intertidal zone
  message('Clipping to intertidal zone raster')
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(surfgrass_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(surfgrass_rast_total)
  writeRaster(surfgrass_rast_total, rast_surfgrass_file, overwrite = TRUE)
} else {
  message('Surfgrass zone raster already exists at: ', rast_surfgrass_file)
}

```

``` {r create_duneveg_raster, echo = FALSE}
### !!! ALL NAs: All dune veg is on land; until we buffer it 1 km inland, leave this layer out
#   
# rast_duneveg_file <- file.path(dir_rast, 'rast_duneveg.tif')

# if(!file.exists(rast_duneveg_file)) {
#   ### Set up a list of file locations to be loaded as polygons.  First line
#   ### determines which layers to read in and load.
#   duneveg_hab_lyrs  <- hab_lyrs %>% 
#     filter(category == 'dune vegetation' & load_layer == TRUE)
# 
#   duneveg_rast_list <- rasterize_layers(duneveg_hab_lyrs)
# 
#   duneveg_rast_brick <- stack(duneveg_rast_list)
#   duneveg_rast_total <- sum(duneveg_rast_brick, na.rm = TRUE) 
#   
#   ### convert zeroes to NA and all values to single value
#   values(duneveg_rast_total)[values(duneveg_rast_total) == 0] <- NA
#   values(duneveg_rast_total)[!is.na(values(duneveg_rast_total))] <- duneveg_hab_lyrs$layer_id[1]
#   
#   ### clip to intertidal zone
#   message('Clipping to intertidal zone raster')
#   rast_zone_intertidal <- raster(rast_zone_intertidal_file)
#   values(duneveg_rast_total)[is.na(values(rast_zone_intertidal))] <- NA
# 
#   plot_raster(duneveg_rast_total) 
#   writeRaster(duneveg_rast_total, rast_duneveg_file, overwrite = TRUE)

# } else {
#   message('Dune vegetation zone raster already exists at: ', rast_duneveg_file)
# }

```

``` {r create_kelp_raster, echo = FALSE}
rast_kelp_file <- file.path(dir_rast, 'rast_kelp.tif')

if(!file.exists(rast_kelp_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  kelp_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'kelp forest' & load_layer == TRUE)

  kelp_rast_list <- rasterize_layers(kelp_hab_lyrs)

  kelp_rast_brick <- stack(kelp_rast_list)
  kelp_rast_total <- sum(kelp_rast_brick, na.rm = TRUE)
  
  ### convert zeroes to NA and all values to single value
  values(kelp_rast_total)[values(kelp_rast_total) == 0] <- NA
  values(kelp_rast_total)[!is.na(values(kelp_rast_total))] <- kelp_hab_lyrs$layer_id[1]
  
  ### NOTE: Not clipping to subtidal coastal region; all instances will probably
  ### be in there, but let it be for now.
  
  plot_raster(kelp_rast_total)
  writeRaster(kelp_rast_total, rast_kelp_file, overwrite = TRUE)
} else {
  message('Kelp zone raster already exists at: ', rast_kelp_file)
}

```

``` {r create_rocky_reef_raster, echo = FALSE}
rast_rocky_reef_file <- file.path(dir_rast, 'rast_rocky_reef.tif')

if(!file.exists(rast_rocky_reef_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  rocky_reef_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'rocky reef' & load_layer == TRUE)

  rocky_reef_rast_list <- rasterize_layers(rocky_reef_hab_lyrs)

  message('Adding in benthic class layer')
  ### Filter the benthic class layer to appropriate cells
  rast_benth_type <- raster(rast_benth_type_file) ### load benthic_class; need to filter to appropriate cells
  values(rast_benth_type)[!values(rast_benth_type) == 3] <- NA ### benthic type 3 is hard substrate
  
  ### then add to rocky_reef_rast_list; then brick it, then sum it
  rocky_reef_rast_list[[length(rocky_reef_rast_list) + 1]] <- rast_benth_type
  rocky_reef_rast_brick <- stack(rocky_reef_rast_list)
  rocky_reef_rast_total <- sum(rocky_reef_rast_brick, na.rm = FALSE) 
    ### leaving in NAs and summing forces an AND situation - ALL layers 
    ### must have a non-NA value.  So: benthic hard AND high rugosity
  
  ### convert zeroes to NA and all values to single value
  values(rocky_reef_rast_total)[values(rocky_reef_rast_total) == 0] <- NA ### not needed?
  values(rocky_reef_rast_total)[!is.na(values(rocky_reef_rast_total))] <- rocky_reef_hab_lyrs$layer_id[1]
  
  ### clip to non-offshore areas (less than 50 m, even including within 1 km of coast?)
  message('Clipping against offshore raster')
  rast_zone_offshore <- raster(rast_zone_offshore_file)
  values(rocky_reef_rast_total)[!is.na(values(rast_zone_offshore))] <- NA
  
  plot_raster(rocky_reef_rast_total)
  writeRaster(rocky_reef_rast_total, rast_rocky_reef_file, overwrite = TRUE)
} else {
  message('Rocky reef zone raster already exists at: ', rast_rocky_reef_file)
}

```

``` {r create_seagrass_raster, echo = FALSE}
### !!! This layer is having issues as well!  fix it.

# rast_seagrass_file <- file.path(dir_rast, 'rast_seagrass.tif')
# 
# if(!file.exists(rast_seagrass_file)) {
#   ### Set up a list of file locations to be loaded as polygons.  First line
#   ### determines which layers to read in and load.
#   seagrass_hab_lyrs  <- hab_lyrs %>% 
#     filter(category == 'seagrass' & load_layer == TRUE)
# 
#   seagrass_rast_list <- rasterize_layers(seagrass_hab_lyrs)
# 
#   seagrass_rast_brick <- stack(seagrass_rast_list)
#   seagrass_rast_total <- sum(seagrass_rast_brick, na.rm = TRUE)
#   
#   ### convert zeroes to NA and all values to single value
#   values(seagrass_rast_total)[values(seagrass_rast_total) == 0] <- NA
#   values(seagrass_rast_total)[!is.na(values(seagrass_rast_total))] <- seagrass_hab_lyrs$layer_id[1]
#   
#   ### NOTE: Not clipping to subtidal coastal region; all instances will probably
#   ### be in there, but let it be for now.
#   
#   plot_raster(seagrass_rast_total)
#   
#   writeRaster(seagrass_rast_total, rast_seagrass_file, overwrite = TRUE)
# } else {
#   message('Seagrass zone raster already exists at: ', rast_seagrass_file)
# }

```


``` {r create_shallow_suspension_raster, echo = FALSE}
rast_shallow_suspension_file <- file.path(dir_rast, 'rast_shallow_suspension.tif')

if(!file.exists(rast_shallow_suspension_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  shallow_suspension_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'shallow suspension reefs' & load_layer == TRUE)

  shallow_suspension_rast_list <- rasterize_layers(shallow_suspension_hab_lyrs)

  shallow_suspension_rast_brick <- stack(shallow_suspension_rast_list)
  shallow_suspension_rast_total <- sum(shallow_suspension_rast_brick, na.rm = TRUE) 

  ### convert zeroes to NA and all values to single value
  values(shallow_suspension_rast_total)[values(shallow_suspension_rast_total) == 0] <- NA ### not needed?
  values(shallow_suspension_rast_total)[!is.na(values(shallow_suspension_rast_total))] <- shallow_suspension_hab_lyrs$layer_id[1]
  
  ### clip to non-offshore areas (less than 50 m, even including within 1 km of coast?)
  message('Clipping against offshore raster')
  rast_zone_offshore <- raster(rast_zone_offshore_file)
  values(shallow_suspension_rast_total)[!is.na(values(rast_zone_offshore))] <- NA
  
  plot_raster(shallow_suspension_rast_total)
  writeRaster(shallow_suspension_rast_total, rast_shallow_suspension_file, overwrite = TRUE)
} else {
  message('Shallow suspension reefs raster already exists at: ', rast_shallow_suspension_file)
}

```

``` {r create_soft_bottom_rasters, echo = FALSE}
rast_soft_shallow_file <- file.path(dir_rast, 'rast_soft_shallow.tif')
rast_soft_shelf_file <- file.path(dir_rast, 'rast_soft_shelf.tif')
rast_soft_slope_file <- file.path(dir_rast, 'rast_soft_slope.tif')
rast_soft_deep_file <- file.path(dir_rast, 'rast_soft_deep.tif')

if(!any(file.exists(rast_soft_shallow_file,
                    rast_soft_shelf_file,
                    rast_soft_slope_file,
                    rast_soft_deep_file))) {

  message('Loading benthic type layer')
  ### Filter the benthic type layer to appropriate cells
  rast_benth_type <- raster(rast_benth_type_file) ### load benthic_class; need to filter to appropriate cells
  values(rast_benth_type)[!values(rast_benth_type) %in% c(1, 2)] <- NA ### benthic type 1 and 2 are mud and sand substrate
  
  ### Initialize all soft-bottom rasters using mud and sand substrate raster
  rast_soft_shallow <- rast_soft_shelf <- rast_soft_slope <- rast_soft_deep <- rast_benth_type

  ### load depth zone rasters
  rast_zone_offshore <- raster(rast_zone_offshore_file)
  rast_zone_shelf <- raster(rast_zone_shelf_file)
  rast_zone_slope <- raster(rast_zone_slope_file)
  rast_zone_deep <- raster(rast_zone_deep_file)

  ### Shallow: clip against offshore
  values(rast_soft_shallow)[!is.na(values(rast_zone_offshore))] <- NA  ### note: include NOT offshore
  values(rast_soft_shallow)[!is.na(values(rast_soft_shallow))] <- hab_lyrs$layer_id[hab_lyrs$category == 'shallow soft bottom']
  
  values(rast_soft_shelf)[is.na(values(rast_zone_shelf))] <- NA
  values(rast_soft_shelf)[!is.na(values(rast_soft_shelf))] <- hab_lyrs$layer_id[hab_lyrs$category == 'soft shelf']

  values(rast_soft_slope)[is.na(values(rast_zone_slope))] <- NA
  values(rast_soft_slope)[!is.na(values(rast_soft_slope))] <- hab_lyrs$layer_id[hab_lyrs$category == 'soft slope']
  
  values(rast_soft_deep)[is.na(values(rast_zone_deep))] <- NA
  values(rast_soft_deep)[!is.na(values(rast_soft_deep))] <- hab_lyrs$layer_id[hab_lyrs$category == 'soft deep']
  
  soft_total <- stack(rast_soft_shallow, rast_soft_shelf, rast_soft_slope, rast_soft_deep) %>% 
    sum(na.rm = TRUE)
  values(soft_total)[values(soft_total == 0)] <- NA
    
  plot_raster(soft_total)
  
  writeRaster(rast_soft_shallow, rast_soft_shallow_file, overwrite = TRUE)
  writeRaster(rast_soft_shelf, rast_soft_shelf_file, overwrite = TRUE)
  writeRaster(rast_soft_slope, rast_soft_slope_file, overwrite = TRUE)
  writeRaster(rast_soft_deep, rast_soft_deep_file, overwrite = TRUE)
} else {
  message('Soft bottom rasters already exists at: \n  %s\n  %s\n  %s\n  %s', 
          rast_soft_shallow_file, rast_soft_shelf_file, rast_soft_slope_file, rast_soft_deep_file)
}

```

``` {r create_hard_bottom_rasters, echo = FALSE}
rast_hard_shallow_file <- file.path(dir_rast, 'rast_hard_shallow.tif')
rast_hard_shelf_file   <- file.path(dir_rast, 'rast_hard_shelf.tif')
rast_hard_slope_file   <- file.path(dir_rast, 'rast_hard_slope.tif')
rast_hard_deep_file    <- file.path(dir_rast, 'rast_hard_deep.tif')

if(!any(file.exists(rast_hard_shallow_file,
                    rast_hard_shelf_file,
                    rast_hard_slope_file,
                    rast_hard_deep_file))) {

  message('Loading benthic type layer')
  ### Filter the benthic type layer to appropriate cells
  rast_benth_type <- raster(rast_benth_type_file) ### load benthic_class; need to filter to appropriate cells
  values(rast_benth_type)[!values(rast_benth_type) %in% c(3)] <- NA ### benthic type 3 is hard substrate
  
  ### Initialize all hard-bottom rasters using mud and sand substrate raster
  rast_hard_shallow <- rast_hard_shelf <- rast_hard_slope <- rast_hard_deep <- rast_benth_type

  ### load depth zone rasters
  rast_zone_offshore <- raster(rast_zone_offshore_file)
  rast_zone_shelf    <- raster(rast_zone_shelf_file)
  rast_zone_slope    <- raster(rast_zone_slope_file)
  rast_zone_deep     <- raster(rast_zone_deep_file)

  ### Shallow: clip against offshore
  values(rast_hard_shallow)[!is.na(values(rast_zone_offshore))] <- NA ### note: include NOT offshore
  values(rast_hard_shallow)[!is.na(values(rast_hard_shallow))] <- -1 # hab_lyrs$layer_id[hab_lyrs$category == 'shallow hard bottom'] ### no place for this
  
  values(rast_hard_shelf)[is.na(values(rast_zone_shelf))] <- NA
  values(rast_hard_shelf)[!is.na(values(rast_hard_shelf))] <- hab_lyrs$layer_id[hab_lyrs$category == 'hard shelf']

  values(rast_hard_slope)[is.na(values(rast_zone_slope))] <- NA
  values(rast_hard_slope)[!is.na(values(rast_hard_slope))] <- hab_lyrs$layer_id[hab_lyrs$category == 'hard slope']
  
  values(rast_hard_deep)[is.na(values(rast_zone_deep))] <- NA
  values(rast_hard_deep)[!is.na(values(rast_hard_deep))] <- hab_lyrs$layer_id[hab_lyrs$category == 'hard deep']
  
  hard_total <- stack(rast_hard_shallow, rast_hard_shelf, rast_hard_slope, rast_hard_deep) %>% 
    sum(na.rm = TRUE)
  values(hard_total)[values(hard_total == 0)] <- NA
  plot_raster(hard_total)
  
  writeRaster(rast_hard_shallow, rast_hard_shallow_file, overwrite = TRUE)
  writeRaster(rast_hard_shelf, rast_hard_shelf_file, overwrite = TRUE)
  writeRaster(rast_hard_slope, rast_hard_slope_file, overwrite = TRUE)
  writeRaster(rast_hard_deep, rast_hard_deep_file, overwrite = TRUE)
} else {
  message('hard bottom rasters already exists at: \n  %s\n  %s\n  %s\n  %s', 
          rast_hard_shallow_file, rast_hard_shelf_file, rast_hard_slope_file, rast_hard_deep_file)
}

```

``` {r create_deep_suspension_raster, echo = FALSE}

### NOTE: !!! This layer, check to make sure polygons have a count (or whatever) greater than zero... Perhaps add a default to the rasterize_layers function, so I can tell it a specific column to look for in these files for the cell value

rast_deep_suspension_file <- file.path(dir_rast, 'rast_deep_suspension.tif')

if(!file.exists(rast_deep_suspension_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  deep_suspension_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'deep suspension reefs' & load_layer == TRUE)

  deep_suspension_rast_list <- rasterize_layers(deep_suspension_hab_lyrs)

  deep_suspension_rast_brick <- stack(deep_suspension_rast_list)
  deep_suspension_rast_total <- sum(deep_suspension_rast_brick, na.rm = TRUE) 

  ### convert zeroes to NA and all values to single value
  values(deep_suspension_rast_total)[values(deep_suspension_rast_total) == 0] <- NA ### not needed?
  values(deep_suspension_rast_total)[!is.na(values(deep_suspension_rast_total))] <- deep_suspension_hab_lyrs$layer_id[1]
  
  ### clip to offshore areas (anything deeper than 50 m)
  message('Clipping against offshore raster')
  rast_zone_offshore <- raster(rast_zone_offshore_file)
  values(deep_suspension_rast_total)[is.na(values(rast_zone_offshore))] <- NA
  
  plot_raster(deep_suspension_rast_total)
  writeRaster(deep_suspension_rast_total, rast_deep_suspension_file, overwrite = TRUE)
} else {
  message('Deep suspension reefs raster already exists at: ', rast_deep_suspension_file)
}

```


``` {r create_hydro_vent_raster, echo = FALSE}
### !!! this layer having problems - is it not buffering points properly?

# rast_hydro_vent_file <- file.path(dir_rast, 'rast_hydro_vent.tif')
# 
# if(!file.exists(rast_hydro_vent_file)) {
#   ### Set up a list of file locations to be loaded as polygons.  First line
#   ### determines which layers to read in and load.
#   hydro_vent_hab_lyrs  <- hab_lyrs %>% 
#     filter(category == 'hydrothermal vents' & load_layer == TRUE)
# 
#   hydro_vent_rast_list <- rasterize_layers(hydro_vent_hab_lyrs)
# 
#   hydro_vent_rast_brick <- stack(hydro_vent_rast_list)
#   hydro_vent_rast_total <- sum(hydro_vent_rast_brick, na.rm = TRUE) 
# 
#   ### convert zeroes to NA and all values to single value
#   values(hydro_vent_rast_total)[values(hydro_vent_rast_total) == 0] <- NA
#   values(hydro_vent_rast_total)[!is.na(values(hydro_vent_rast_total))] <- hydro_vent_hab_lyrs$layer_id[1]
#   
#   plot_raster(hydro_vent_rast_total)
#   writeRaster(hydro_vent_rast_total, rast_hydro_vent_file, overwrite = TRUE)
# } else {
#   message('Hydrothermal vents raster already exists at: ', rast_hydro_vent_file)
# }

```


``` {r child = file.path(dir_git, 'src/templates/ohibc_prov_ftr.Rmd'), eval = FALSE}
```
