---
title: "OHIBC Pressures habitat layer preparation"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ohibc/src/templates/ohibc_hdr1.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}
library(sp)        # the classes and methods that make up spatial ops in R
library(rgdal)
library(maptools)
library(raster)
library(DT)

dir_git <- '~/github/ohibc'
dir_rgn <- file.path(dir_git, 'prep/regions')  ### github: general buffer region shapefiles
  
source(file.path(dir_git, 'src/R/common.R'))  ### an OHIBC specific version of common.R

### goal specific folders and info
dir_hab  <- file.path(dir_git, 'prep/pressures/habitats')
scenario <- 'v2016'
dir_anx  <- file.path(dir_neptune_data, 'git-annex/bcprep')
#dir_rast <- file.path(dir_anx, 'pressures/habitats')
dir_rast <- file.path(dir_hab, 'raster')

### provenance tracking
# source('~/github/ohibc/src/R/prov.R')      
#   ### Provenance tracking functions: must source at start to initialize prov_track
# dir_prov <- file.path(dir_hab, 'prov') 
#   ### set a provenance folder for this script
# this_script_file <- file.path(dir_hab, 'layer_prep_pressures_habs.Rmd') 
#   ### can't recognize the current script name on its own :(
# prov_run_tag <- 'standard run'

### goal-specific source scripts
# source(file.path(dir_spp, 'R/spp_fxn.R'))
# git_prov(file.path(dir_spp, 'R/spp_fxn.R'), type = 'sourced_script')

### set up proj4string options: BC Albers and WGS84
p4s_bcalb <- CRS('+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0')
```

``` {r raster plot function, echo = FALSE}
plot_raster <- function(rast,
#                             poly_rgn,
                            title = '', scale_label = '',
                            scale_limits = c(0, max(values(rast), na.rm = TRUE)),
#                             by_id = 'loiczid',
                            rev_scale = FALSE) {
  require(ggplot2)
  require(RColorBrewer)
  require(maptools)

  rast_pts <- raster::rasterToPoints(rast) %>%
    as.data.frame()
  names(rast_pts) <- c('x', 'y', 'layer')
  rast_pts <- rast_pts %>%
    mutate(group = 1) ### need 'group' variable to plot below...

  if(rev_scale == TRUE) {
    cols <- rev(colorRampPalette(brewer.pal(11, 'Spectral'))(255)) # rainbow color scheme, low = blue
  } else {
    cols <- colorRampPalette(brewer.pal(11, 'Spectral'))(255) # rainbow color scheme, low = red
  }

#   poly_rgn_df <- fortify(poly_rgn, region = 'rgn_id') %>%
#     rename(rgn_id = id) %>%
#     mutate(rgn_id = as.integer(rgn_id))

  poly_land    <- readShapePoly(fn = file.path(dir_rgn, 'ohibc_land'), proj4string = p4s_bcalb)
  poly_land_df <- fortify(poly_land) %>%
    rename(x = long, y = lat)

  rast_plot <- ggplot(data = rast_pts, aes(x = x, y = y, group = group, fill = layer)) +
    ### omit ticks, axis text:
    theme(axis.ticks = element_blank(), axis.text = element_blank()) +
    ### set text style, title size and position, and legend position:
    theme(text = element_text(family = 'Helvetica', color = 'gray30', size = 12),
          plot.title = element_text(size = rel(1.5), hjust = 0, face = 'bold'),
          legend.position = 'right') +
    ### Blank background and grid:
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank()) +
    scale_fill_gradientn(colours = cols, na.value = 'gray80',
                        limits = scale_limits) +
    geom_raster(alpha = .8) +
    geom_polygon(data = poly_land_df, color = 'gray70', fill = 'gray75', size = 0.1) +
    # geom_polygon(data = poly_rgn_df,  color = 'gray20', fill = NA,       size = 0.1) +
    labs(title = title,
         fill  = scale_label,
         x = NULL, y = NULL)

  print(rast_plot)
}

```

Assemble a habitat map for OHIBC pressures calculations.

Projection: BC Albers

Raster: 
* 500 m cell size - need to resolve 1 km features (e.g. intertidal buffer)

``` {r load_habitat_layers_list, echo = FALSE}

hab_lyrs <- read_csv(file.path(dir_hab, 'pressures_hab_layers.csv'))

# tmp <- hab_lyrs %>% mutate(
#   layer_name = str_split(layer_name, ','))
# 
# layer_df <- data.frame()
# for (i in 1:nrow(tmp)) { # i = 2
#   tmp_info  <- tmp[i, ] %>% select(-layer_name)
#   tmp_long <- unlist(tmp[i, ]$layer_name)
#   tmp_df <- data.frame(tmp_info, tmp_long)
#   layer_df <- bind_rows(layer_df, tmp_df)
# }
# hab_lyrs <- layer_df %>%
#   mutate(category = str_trim(tolower(category)),
#          data_desc = str_trim(tolower(data_desc)),
#          data_ban2010 = str_trim(data_ban2010),
#          tmp_long = str_trim(tmp_long)) %>%
#   rename(layer_name = tmp_long)
# 
# hab_dirs <- read_csv(file.path(dir_hab, 'bcmca_shps_all.csv'))
# 
# hab_lyrs <- hab_lyrs %>%
#   mutate(layer_name = paste(layer_name, '.shp', sep = '')) %>%
#   left_join(hab_dirs %>%
#               select(dir, layer_name = shp),
#             by = 'layer_name')
# 
# write_csv(hab_lyrs, file.path(dir_hab, 'pressures_hab_layers.csv'))


DT::datatable(hab_lyrs)
```

# Set up depth regions: coastal intertidal, shallow, shelf, slope, deep

Define shelf/slope/deep not by 60m/200m/2000m (per CHI 2015) but by:

* "deep" is bottom of continental slope - outline defined by shoremost boundary of Pacific Offshore region
* "shelf" is top of continental slope - all area less than 200 m, outside of Pacific Offshore region
* "slope" is region between shelf and slope

The steps:

* Create raster of benthic class layer.
* Create raster of intertidal layer
    * create a 1 km buffer around land (intertidal proxy)
    * rasterize land polygon and 1 km buffer polygon
    * subtract land from 1 km buffer to create intertidal
* create raster of deep/abyssal zone
    * use Pacific Offshore region - inland boundary is base of slope
    * rasterize PO polygon
* use benthic raster depth values, with deep and intertidal as boundaries

``` {r rasterize_benthic_class, echo = FALSE}
### Benthic Class is a commonly used layer for habitats - depth and substrate in particular.
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_benthic_class_file <- file.path(dir_rast, 'rast_benthic_class_atF.tif')

if(!file.exists(rast_benthic_class_file)) {
  message('Creating benthic_class raster: ', rast_benthic_class_file)
  
  library(gdalUtils)
  
  ### figure out source file location for polygon
  zone_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'BenthicClass'))
  zone_shp  <- file.path(dir_anx, 'data', zone_lyrs[1, ]$dir, paste(zone_lyrs[1, ]$layer_name, '.shp', sep = ''))

  ### rasterize the beast
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  library(gdalUtils)
  rast_benthic_class <- gdal_rasterize(src_datasource = zone_shp, 
                                 dst_filename   = rast_benthic_class_file,
                                 a = 'Marxan_ID', # attribute to burn
                                 a_nodata = NA,
                                 # at = TRUE,
                                 te = base_te,
                                 tr = c(500, 500),
                                 output_Raster = TRUE)
  ### this saves an 80+ MB file; But raster::rasterize is really slow.
  
} else {
  message(sprintf('Loading benthic_class raster from %s', rast_benthic_class_file))
  rast_benthic_class <- raster(rast_benthic_class_file)
}

  # writeRaster(rast_benthic_class, rast_benthic_class_file, overwrite = TRUE)

plot_raster(rast_benthic_class)

```


Setting up zone rasters.  Cells will be identified with values according to zone:

* 1 = intertidal
* 2 = coastal
* 3 = shelf
* 4 = slope
* 5 = deep/abyssal plane
* 6 = offshore
* NA = not in a zone

``` {r create_intertidal_raster, echo = FALSE}
rast_zone_intertidal_file <- file.path(dir_rast, 'rast_zone_intertidal.tif')

### rast_zone_intertidal.tif seems to be screwed up.  Need to create 1 km offshore buffer;
### then use gdal_rasterize on that fucker.
if(!file.exists(rast_zone_intertidal_file)) {
  message(sprintf('Missing intertidal zone raster; creating new: %s', 
                  rast_zone_intertidal_file))

  poly_intertidal_file <- file.path(dir_rgn, 'ohibc_offshore_1km')
  if(!file.exists(paste(poly_intertidal_file, '.shp', sep = ''))) {
    ### create a polygon for 1 km offshore regions.
    poly_land <- readOGR(dsn = path.expand(dir_rgn), 
                         layer = 'ohibc_land', 
                         stringsAsFactors = FALSE) %>%
      createSPComment(which = NULL, overwrite = TRUE)
	
    poly_buffer <- raster::buffer(poly_land, width = 1000)

    poly_bc_rgn <- readOGR(dsn = path.expand(dir_rgn), 
                           layer = 'ohibc_rgn', 
                           stringsAsFactors = FALSE)
    poly_intertidal <- raster::intersect(poly_buffer, poly_bc_rgn)
    
    writePolyShape(poly_intertidal, poly_intertidal_file)
                                            
  } else {
    poly_intertidal <- readShapePoly(poly_intertidal_file,
                                     proj4string = p4s_bcalb)
  }
  
  ### Now we have an intertidal layer.  Rasterize it!
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_benthic_class <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_intertidal_file, '.shp', sep = '')), 
      dst_filename   = rast_zone_intertidal_file,
      a = 'rgn_id', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = c(500, 500),
      output_Raster = TRUE
    )
  })

  ### code layers to be uniform zone ID
  values(rast_zone_intertidal)[!is.na(values(rast_zone_intertidal))] <- 1

  writeRaster(rast_zone_intertidal, rast_zone_intertidal_file, overwrite = TRUE)

} else {
  message(sprintf('Intertidal zone raster exists; reading from %s', 
          rast_zone_intertidal_file))
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
}

### set up 1 km offshore layer
# poly_ohibc_land <- readShapePoly(file.path(dir_rgn, 'ohibc_land'), proj4string = p4s_bcalb)
# poly_ohibc_rgn  <- readShapePoly(file.path(dir_rgn, 'ohibc_rgn'),  proj4string = p4s_bcalb)
# 
# poly_land_1kmbuffer <- gBuffer(poly_ohibc_land, width = 1000)
# poly_ohibc_offshore_1km <- gIntersection(poly_land_1kmbuffer, poly_ohibc_rgn, byid = TRUE)

```

``` {r create_deep_raster, echo = FALSE}
rast_zone_deep_file <- file.path(dir_rast, 'rast_zone_deep.tif')

if(!file.exists(rast_zone_deep_file)) {
  message('Missing deep zone raster; creating new file: ', rast_zone_deep_file)
  poly_bc_rgn     <- readShapePoly(file.path(dir_rgn, 'ohibc_rgn'),
                                   proj4string = p4s_bcalb)
  ### for deep zone, filter out all but the PO region
  poly_deep <- poly_bc_rgn[poly_bc_rgn@data$rgn_code == 'PO', ]
  
  message('This process is using raster::rasterize - check results! ', 
          rast_zone_deep_file)
  
  system.time({
    rast_zone_deep <- rasterize(poly_deep, rast_base)
  })
  
  ### code layers to be uniform zone ID
  values(rast_zone_deep)[!is.na(values(rast_zone_deep))] <- 5

  writeRaster(rast_zone_deep, rast_zone_deep_file, overwrite = TRUE)

} else {
  message(sprintf('Deep zone raster exists; reading from %s', 
          rast_zone_deep_file))
  rast_zone_deep       <- raster(rast_zone_deep_file)
}

```

``` {r create_zones_from_depths, echo = FALSE}

rast_zone_coastal_file <- file.path(dir_rast, 'rast_zone_coastal.tif')
rast_zone_shelf_file <- file.path(dir_rast, 'rast_zone_shelf.tif')
rast_zone_slope_file <- file.path(dir_rast, 'rast_zone_slope.tif')
rast_zone_offshore_file <- file.path(dir_rast, 'rast_zone_offshore.tif')

if(any(!file.exists(c(rast_zone_coastal_file, 
                      rast_zone_shelf_file, 
                      rast_zone_slope_file, 
                      rast_zone_offshore_file))) {
  ### Create each of these rasters based on benthic_class codes, and masking from
  ### deep and intertidal rasters created above.
  
  # * `benthic_class` will be divided to depth, substrate, and formation according to the rule for field `ID`:
  #     * 1000's = depth              * 10's = substrate          * 1's = BPI
  #         * 1000 <- 0 - 20 m            * 10 <- mud                 * 1 <- ridge
  #         * 2000 <- 20 - 50 m           * 20 <- sand                * 2 <- depression
  #         * 3000 <- 50 - 200 m          * 30 <- hard                * 3 <- flat
  #         * 4000 <- 200 m +             * 90 <- unknown             * 4 <- slope
  
  rast_depthzone <- floor(rast_benthic_class/1000) 
  
  ### initialize zonal rasters to base_raster
  rast_zone_coastal <- rast_zone_shelf <- rast_zone_slope <- rast_zone_offshore <- rast_base
  
  ### rast_zone_coastal includes cells 50 m or shallower, excluding intertidal.
  values(rast_zone_coastal)[values(rast_depthzone) %in% c(1, 2)] <- 2
  values(rast_zone_coastal)[!is.na(values(rast_zone_intertidal))] <- NA
  
  ### rast_zone_shelf includes cells between 50 and 200 m, excluding intertidal and
  ### Pacific Offshore (deep)
  values(rast_zone_shelf)[values(rast_depthzone) == 3] <- 3
  values(rast_zone_shelf)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_shelf)[!is.na(values(rast_zone_deep))]       <- NA
  
  ### rast_zone_slope includes cells deeper than 200 m, excluding the Pacific Offshore
  ### region (abyssal plain) and any intertidal that somehow gets in the way
  values(rast_zone_slope)[values(rast_depthzone) == 4] <- 4
  values(rast_zone_slope)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_slope)[!is.na(values(rast_zone_deep))]       <- NA

  ### rast_zone_offshore is *all* deeper than 50 m, excluding any intertidal
  values(rast_zone_offshore)[values(rast_depthzone) %in% c(2, 3, 4)] <- 6
  values(rast_zone_offshore)[!is.na(values(rast_zone_intertidal))] <- NA

  writeRaster(rast_zone_coastal,  rast_zone_coastal_file,  overwrite = TRUE)
  writeRaster(rast_zone_shelf,    rast_zone_shelf_file,    overwrite = TRUE)
  writeRaster(rast_zone_slope,    rast_zone_slope_file,    overwrite = TRUE)
  writeRaster(rast_zone_offshore, rast_zone_offshore_file, overwrite = TRUE)

} else {
  message('Coastal, shelf, slope, and offshore zone rasters exist:')
  message(sprintf('Reading from: %s, %s, %s, %s', 
          rast_zone_coastal_file, rast_zone_shelf_file, rast_zone_slope_file, rast_zone_offshore_file))
  rast_zone_coastal  <- raster(rast_zone_coastal_file)
  rast_zone_shelf    <- raster(rast_zone_shelf_file)
  rast_zone_slope    <- raster(rast_zone_slope_file)
  rast_zone_offshore <- raster(rast_zone_offshore_file)
}

y <- sum(rast_zone_intertidal, rast_zone_coastal, rast_zone_shelf, rast_zone_slope, rast_zone_deep, na.rm = TRUE)
values(y)[values(y) == 0] <- NA

plot_raster(y)

remove(y)

```

``` {r setup_coastal_classes, echo = FALSE}
### Set up coastal_classes raster:
### * buffer the lines
### * rasterize and save
rast_coastal_class_file <- file.path(dir_rast, 'rast_coastal_class.tif')
if(!file.exists(rast_coastal_class_file)) {
  poly_coastal_class_file <- file.path(dir_rast, 'poly_coastal_class')
  if(!file.exists(poly_coastal_class_file)) {
    coastal_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'CoastalClass'))
    coastal_shp_file <- file.path(dir_anx, 'data', coastal_lyrs[1, ]$dir, 
                                  paste(coastal_lyrs[1, ]$layer_name, '.shp', sep = ''))
    line_coastal <- readShapeLines(coastal_shp_file, proj4string = p4s_bcalb)
    ptc <- proc.time()
    poly_coastal <- gBuffer(line_coastal, 
                            byid = TRUE,
                            width = 1000,
                            capStyle = 'FLAT')
    proc.time() - ptc # 609 seconds for full shapefile
    writePolyShape(poly_coastal, poly_coastal_class_file)
  } else {
    poly_coastal <- readShapePoly(poly_coastal_class_file, 
                                  proj4string = p4s_bcalb)
  }
  
  ### Now to create the raster... 
  #   # set tmp directory
  #   tmpdir <- file.path(dir_neptune_data, 'home_big/ohara/R_raster_tmp')
  #   dir.create(tmpdir, showWarnings = F)
  #   rasterOptions(tmpdir = tmpdir)
  # 
  #   ptc <- proc.time()
  #   rast_coastal_class <- rasterize(poly_coastal, rast_base, field = 'ID')
  #   proc.time() - ptc 
  #   
  #   writeRaster(rast_coastal_class, rast_coastal_class_file, overwrite = TRUE)

  ### OR:
  library(gdalUtils)
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  rast_benthic_class <- gdal_rasterize(src_datasource = path.expand(paste(poly_coastal_class_file, '.shp', sep= '')), 
                                       dst_filename   = path.expand(rast_coastal_class_file),
                                       a = 'ID', # attribute to burn
                                       a_nodata = NA,
                                       # at = TRUE, # all touched option...
                                       te = base_te,
                                       tr = c(500, 500),
                                       output_Raster = TRUE)
} else {
  rast_coastal_class <- raster(rast_coastal_class_file)
}

### Now to break down the coastal classes by type.
# * `coastalclasses` will be determined according to the rule from field `ID`:
#     * Initial digit (2) is unused?; delete
#     * Next two digits (0 - 34) denote the coastal class according to
#         http://alaskafisheries.noaa.gov/mapping/DataDictionary/Common/ShoreType.htm
#     * final one or two digits represents geographic region; delete

### First, ditch trailing digit for five-digit values (two-digit regions)
values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                           values(rast_coastal_class) > 10000] <- 
  floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                                   values(rast_coastal_class) > 10000]/10)
### Then, ditch trailing digit for all values
values(rast_coastal_class)[!is.na(values(rast_coastal_class))] <- 
  floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class))]/10)
### Then, subtract 200 to ditch the leading value
rast_coastal_class <- rast_coastal_class - 200

plot_raster(rast_coastal_class)

```


``` {r create_intertidal_rasters, echo = FALSE}

### Set up a list of file locations to be loaded as polygons.
  int_poly_lyrs <- hab_lyrs %>% filter(zone == 'intertidal' & layer_type == 'poly')
  int_poly_files  <- file.path(dir_anx, 'data', int_poly_lyrs$dir, 
                               paste(int_poly_lyrs$layer_name, '.shp', sep = ''))
  int_poly_files <- int_poly_files[!str_detect(int_poly_files, 'BenthicClass')] %>% 
    unique()
  int_poly_list <- lapply(int_poly_files, function(x) {readShapePoly(x, proj4string = p4s_bcalb)})
  names(int_poly_list) <- basename(int_poly_files)
  

### Set up a list of file locations to be loaded as lines.
  int_line_lyrs <- hab_lyrs %>% filter(zone == 'intertidal' & layer_type == 'line')
  int_line_files  <- file.path(dir_anx, 'data', int_line_lyrs$dir, 
                               paste(int_line_lyrs$layer_name, '.shp', sep = ''))
  int_line_files <- int_line_files %>% 
    unique()
  int_line_list <- lapply(int_line_files, function(x) {readShapeLines(x, proj4string = p4s_bcalb)})
  names(int_line_list) <- basename(int_line_files)
```


``` {r child = file.path(dir_git, 'src/templates/ohibc_prov_ftr.Rmd'), eval = FALSE}
```
