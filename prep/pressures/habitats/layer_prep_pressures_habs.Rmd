---
title: "OHIBC Pressures habitat layer preparation"
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ohibc/src/templates/ohibc_hdr1.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}
library(sp)        # the classes and methods that make up spatial ops in R
library(rgdal)
library(maptools)
library(raster)
library(DT)

dir_git <- '~/github/ohibc'
dir_rgn <- file.path(dir_git, 'prep/regions')  ### github: general buffer region shapefiles
  
source(file.path(dir_git, 'src/R/common.R'))  ### an OHIBC specific version of common.R

### goal specific folders and info
dir_hab  <- file.path(dir_git, 'prep/pressures/habitats')
scenario <- 'v2016'
dir_anx  <- file.path(dir_neptune_data, 'git-annex/bcprep')
#dir_rast <- file.path(dir_anx, 'pressures/habitats')
dir_rast <- file.path(dir_hab, 'raster')

### provenance tracking
# source('~/github/ohibc/src/R/prov.R')
#   ### Provenance tracking functions: must source at start to initialize prov_track
# dir_prov <- file.path(dir_hab, 'prov')
#   ### set a provenance folder for this script
# this_script_file <- file.path(dir_hab, 'layer_prep_pressures_habs.Rmd')
#   ### can't recognize the current script name on its own :(
# prov_run_tag <- 'standard run'

### goal-specific source scripts
# source(file.path(dir_spp, 'R/spp_fxn.R'))
# git_prov(file.path(dir_spp, 'R/spp_fxn.R'), type = 'sourced_script')

### set up CRS for BC Albers based on proj4string.
p4s_bcalb <- CRS('+proj=aea +lat_1=50 +lat_2=58.5 +lat_0=45 +lon_0=-126 +x_0=1000000 +y_0=0 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0')

```

``` {r raster plot function, echo = FALSE}
plot_raster <- function(rast,
                            title = '', scale_label = '',
                            scale_limits = c(0, max(values(rast), na.rm = TRUE)),
                            rev_scale = FALSE) {
  require(ggplot2)
  require(RColorBrewer)
  require(maptools)

  rast_pts <- raster::rasterToPoints(rast) %>%
    as.data.frame()
  names(rast_pts) <- c('x', 'y', 'layer')
  rast_pts <- rast_pts %>%
    mutate(group = 1) ### need 'group' variable to plot below...

  if(rev_scale == TRUE) {
    cols <- rev(colorRampPalette(brewer.pal(11, 'Spectral'))(255)) # rainbow color scheme, low = blue
  } else {
    cols <- colorRampPalette(brewer.pal(11, 'Spectral'))(255) # rainbow color scheme, low = red
  }

#   poly_rgn <- readShapePoly(fn = file.path(dir_rgn, 'ohibc_rgn'), proj4string = p4s_bcalb)
#   poly_rgn_df <- fortify(poly_rgn, region = 'rgn_id') %>%
#     rename(rgn_id = id, x = long, y = lat) %>%
#     mutate(rgn_id = as.integer(rgn_id))

  poly_land <- readShapePoly(fn = file.path(dir_rgn, 'ohibc_land'), proj4string = p4s_bcalb)
  poly_land_df <- fortify(poly_land) %>%
    rename(x = long, y = lat)
  
  x <- c(159000, 1237700, 174000, 1223000) # from extent of poly_rgn; just hard code it.

  rast_plot <- ggplot(data = rast_pts, aes(x = x, y = y, group = group, fill = layer)) +
    ### omit ticks, axis text:
    theme(axis.ticks = element_blank(), axis.text = element_blank()) +
    ### set text style, title size and position, and legend position:
    theme(text = element_text(family = 'Helvetica', color = 'gray30', size = 12),
          plot.title = element_text(size = rel(1.5), hjust = 0, face = 'bold'),
          legend.position = 'right') +
    ### Blank background and grid:
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank()) +
    scale_fill_gradientn(colours = cols, na.value = 'gray80',
                        limits = scale_limits) +
    geom_raster(alpha = .8) +
    geom_polygon(data = poly_land_df, color = 'gray70', fill = 'gray75', size = 0.1) +
    # geom_polygon(data = poly_rgn_df,  color = 'gray20', fill = NA,       size = 0.1) +
    coord_cartesian(xlim = c(x[1], x[2]), ylim = c(x[3], x[4]), expand = TRUE) +
    labs(title = title,
         fill  = scale_label,
         x = NULL, y = NULL)

  print(rast_plot)
}

```

Assemble a habitat map for OHIBC pressures calculations.

Projection: BC Albers

Raster: 
* 500 m cell size - need to resolve 1 km features (e.g. intertidal buffer)

``` {r load_habitat_layers_list, echo = FALSE}

hab_lyrs <- read_csv(file.path(dir_hab, 'pressures_hab_layers.csv'))

# hab_dirs <- read_csv(file.path(dir_hab, 'bcmca_shps_all.csv'))
# 
# hab_lyrs <- hab_lyrs %>%
#   mutate(layer_name = paste(layer_name, '.shp', sep = '')) %>%
#   left_join(hab_dirs %>%
#               select(dir, layer_name = shp),
#             by = 'layer_name')
# 
# write_csv(hab_lyrs, file.path(dir_hab, 'pressures_hab_layers.csv'))

DT::datatable(hab_lyrs)

```

# Set up depth regions: coastal intertidal, shallow, shelf, slope, deep

Define shelf/slope/deep not by 60m/200m/2000m (per CHI 2015) but by:

* "deep" is bottom of continental slope - outline defined by shoremost boundary of Pacific Offshore region
* "shelf" is top of continental slope - all area less than 200 m, outside of Pacific Offshore region
* "slope" is region between shelf and slope

The steps:

* Create raster of benthic class layer.
* Create raster of intertidal layer
    * create a 1 km buffer around land (intertidal proxy)
    * rasterize land polygon and 1 km buffer polygon
    * subtract land from 1 km buffer to create intertidal
* create raster of deep/abyssal zone
    * use Pacific Offshore region - inland boundary is base of slope
    * rasterize PO polygon
* use benthic raster depth values, with deep and intertidal as boundaries

``` {r rasterize_benthic_class, echo = FALSE}
### Benthic Class is a commonly used layer for habitats - depth and substrate in particular.
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_benthic_class_file <- file.path(dir_rast, 'rast_benthic_class_atF.tif')

if(!file.exists(rast_benthic_class_file)) {
  message('Creating benthic_class raster: ', rast_benthic_class_file)
  
  library(gdalUtils)
  
  ### figure out source file location for polygon
  zone_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'BenthicClass'))
  zone_shp  <- file.path(dir_anx, 'data', zone_lyrs[1, ]$dir, paste(zone_lyrs[1, ]$layer_name, '.shp', sep = ''))

  ### rasterize the beast
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  library(gdalUtils)
  rast_benthic_class <- gdal_rasterize(src_datasource = zone_shp, 
                                 dst_filename   = rast_benthic_class_file,
                                 a = 'Marxan_ID', # attribute to burn
                                 a_nodata = NA,
                                 # at = TRUE,
                                 te = base_te,
                                 tr = c(500, 500),
                                 output_Raster = FALSE)
  ### this saves an 80+ MB file; But raster::rasterize is really slow.
  
  remove(rast_benthic_class) # clear memory
  
} else {
  message(sprintf('Benthic_class raster already exists at: %s', rast_benthic_class_file))
}

  # writeRaster(rast_benthic_class, rast_benthic_class_file, overwrite = TRUE)

```

Setting up zone rasters.  Cells will be identified with values according to zone:

* 1 = intertidal
* 2 = coastal
* 3 = shelf
* 4 = slope
* 5 = deep/abyssal plane
* 6 = offshore
* NA = not in a zone

``` {r create_intertidal_zone_raster, echo = FALSE}

rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_zone_intertidal_file <- file.path(dir_rast, 'rast_zone_intertidal.tif')

if(!file.exists(rast_zone_intertidal_file)) {
  message(sprintf('Missing intertidal zone raster; creating new: %s', 
                  rast_zone_intertidal_file))

  poly_intertidal_file <- file.path(dir_rgn, 'ohibc_offshore_1km')
  if(!file.exists(paste(poly_intertidal_file, '.shp', sep = ''))) {
    ### create a polygon for 1 km offshore regions.
    poly_land <- readOGR(dsn = path.expand(dir_rgn), 
                         layer = 'ohibc_land', 
                         stringsAsFactors = FALSE) %>%
      createSPComment(which = NULL, overwrite = TRUE)
	
    poly_buffer <- raster::buffer(poly_land, width = 1000)

    poly_bc_rgn <- readOGR(dsn = path.expand(dir_rgn), 
                           layer = 'ohibc_rgn', 
                           stringsAsFactors = FALSE)
    poly_intertidal <- raster::intersect(poly_buffer, poly_bc_rgn)
    
    writePolyShape(poly_intertidal, poly_intertidal_file)
                                            
  } else {
    poly_intertidal <- readShapePoly(poly_intertidal_file,
                                     proj4string = p4s_bcalb)
  }
  
  ### Now we have an intertidal layer.  Rasterize it!
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_zone_intertidal <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_intertidal_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_zone_intertidal_file),
      a = 'rgn_id', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = c(500, 500),
      output_Raster = TRUE
    )
  })

  ### code layers to be uniform zone ID
  values(rast_zone_intertidal)[!is.na(values(rast_zone_intertidal))] <- 1

  writeRaster(rast_zone_intertidal, rast_zone_intertidal_file, overwrite = TRUE)
  
  remove(rast_zone_intertidal) # clean up memory

} else {
  message(sprintf('Intertidal zone raster already exists: %s', 
          rast_zone_intertidal_file))
}

```

``` {r create_deep_zone_raster, echo = FALSE}
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_zone_deep_file <- file.path(dir_rast, 'rast_zone_deep.tif')

if(!file.exists(rast_zone_deep_file)) {
  message('Missing deep zone raster; creating new file: ', rast_zone_deep_file)
  poly_bc_rgn     <- readShapePoly(file.path(dir_rgn, 'ohibc_rgn'),
                                   proj4string = p4s_bcalb)
  ### for deep zone, filter out all but the PO region
  poly_deep <- poly_bc_rgn[poly_bc_rgn@data$rgn_code == 'PO', ]
  poly_deep_file <- file.path(dir_rast, 'poly_deep')
  writePolyShape(poly_deep, poly_deep_file)
  
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_zone_deep <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_deep_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_zone_deep_file),
      a = 'rgn_id', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = c(500, 500),
      output_Raster = TRUE
    )
  })
  
  ### code layers to be uniform zone ID
  values(rast_zone_deep)[!is.na(values(rast_zone_deep))] <- 5

  writeRaster(rast_zone_deep, rast_zone_deep_file, overwrite = TRUE)
  
  remove(rast_zone_deep) # clean up memory

} else {
  message(sprintf('Deep zone raster already exists at: %s', 
          rast_zone_deep_file))
}

```

``` {r create_depth_rasters, echo = FALSE}

rast_zone_coastal_file <- file.path(dir_rast, 'rast_zone_coastal.tif')
rast_zone_shelf_file <- file.path(dir_rast, 'rast_zone_shelf.tif')
rast_zone_slope_file <- file.path(dir_rast, 'rast_zone_slope.tif')
rast_zone_offshore_file <- file.path(dir_rast, 'rast_zone_offshore.tif')

if(any(!file.exists(c(rast_zone_coastal_file, 
                      rast_zone_shelf_file, 
                      rast_zone_slope_file, 
                      rast_zone_offshore_file)))) {
  ### Create each of these rasters based on benthic_class codes, and masking from
  ### deep and intertidal rasters created above.
  
  # * `benthic_class` will be divided to depth, substrate, and formation according to the rule for field `ID`:
  #     * 1000's = depth              * 10's = substrate          * 1's = BPI
  #         * 1000 <- 0 - 20 m            * 10 <- mud                 * 1 <- ridge
  #         * 2000 <- 20 - 50 m           * 20 <- sand                * 2 <- depression
  #         * 3000 <- 50 - 200 m          * 30 <- hard                * 3 <- flat
  #         * 4000 <- 200 m +             * 90 <- unknown             * 4 <- slope
  
  rast_depthzone <- floor(rast_benthic_class/1000) 
  
  ### initialize zonal rasters to base_raster
  rast_zone_coastal <- rast_zone_shelf <- rast_zone_slope <- rast_zone_offshore <- rast_base
  
  ### rast_zone_coastal includes cells 50 m or shallower, excluding intertidal.
  values(rast_zone_coastal)[values(rast_depthzone) %in% c(1, 2)] <- 2
  values(rast_zone_coastal)[!is.na(values(rast_zone_intertidal))] <- NA
  
  ### rast_zone_shelf includes cells between 50 and 200 m, excluding intertidal and
  ### Pacific Offshore (deep)
  values(rast_zone_shelf)[values(rast_depthzone) == 3] <- 3
  values(rast_zone_shelf)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_shelf)[!is.na(values(rast_zone_deep))]       <- NA
  
  ### rast_zone_slope includes cells deeper than 200 m, excluding the Pacific Offshore
  ### region (abyssal plain) and any intertidal that somehow gets in the way
  values(rast_zone_slope)[values(rast_depthzone) == 4] <- 4
  values(rast_zone_slope)[!is.na(values(rast_zone_intertidal))] <- NA
  values(rast_zone_slope)[!is.na(values(rast_zone_deep))]       <- NA

  ### rast_zone_offshore is *all* deeper than 50 m, excluding any intertidal
  values(rast_zone_offshore)[values(rast_depthzone) %in% c(2, 3, 4)] <- 6
  values(rast_zone_offshore)[!is.na(values(rast_zone_intertidal))] <- NA

  writeRaster(rast_zone_coastal,  rast_zone_coastal_file,  overwrite = TRUE)
  writeRaster(rast_zone_shelf,    rast_zone_shelf_file,    overwrite = TRUE)
  writeRaster(rast_zone_slope,    rast_zone_slope_file,    overwrite = TRUE)
  writeRaster(rast_zone_offshore, rast_zone_offshore_file, overwrite = TRUE)

  remove(rast_zone_coastal, rast_zone_shelf, rast_zone_slope, rast_zone_offshore) # clean up memory

} else {
  message('Coastal, shelf, slope, and offshore zone rasters already exist:')
  message(sprintf('  %s \n  %s \n  %s \n  %s', 
          rast_zone_coastal_file, rast_zone_shelf_file, rast_zone_slope_file, rast_zone_offshore_file))
#   rast_zone_coastal  <- raster(rast_zone_coastal_file)
#   rast_zone_shelf    <- raster(rast_zone_shelf_file)
#   rast_zone_slope    <- raster(rast_zone_slope_file)
#   rast_zone_offshore <- raster(rast_zone_offshore_file)
}

```

``` {r rasterize_coastal_class, echo = FALSE}
### Set up coastal_classes raster:
### * buffer the lines - add extra width to avoid holes
### * rasterize, then mask with intertidal zone
### * translate codes to coastal class only, and save
rast_base <- raster(file.path(dir_rgn,  'ohibc_base_raster_500m.tif'))
rast_coastal_class_file <- file.path(dir_rast, 'rast_coastal_class.tif')

if(!file.exists(rast_coastal_class_file)) {
  message('No coastal class raster found at: ', rast_coastal_class_file)
  
  poly_coastal_class_file <- file.path(dir_rast, 'poly_coastal_class')
  if(!file.exists(paste(poly_coastal_class_file, '.shp', sep = ''))) {
    coastal_lyrs <- hab_lyrs %>% filter(str_detect(layer_name, 'CoastalClass'))
    coastal_shp_file <- file.path(dir_anx, 'data', coastal_lyrs[1, ]$dir, 
                                  paste(coastal_lyrs[1, ]$layer_name, '.shp', sep = ''))
    line_coastal <- readShapeLines(coastal_shp_file, proj4string = p4s_bcalb)
    ptc <- proc.time()
    poly_coastal <- gBuffer(line_coastal, 
                            byid = TRUE,
                            width = 2000,
                            capStyle = 'FLAT')
    proc.time() - ptc # 609 seconds for full shapefile
    writePolyShape(poly_coastal, poly_coastal_class_file)
  } else {
    poly_coastal <- readShapePoly(poly_coastal_class_file, 
                                  proj4string = p4s_bcalb)
  }
  
  ### Now to create the raster... 
  
  system.time({
    base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
    library(gdalUtils)
    rast_coastal_class <- gdal_rasterize(
      src_datasource = path.expand(paste(poly_coastal_class_file, '.shp', sep = '')), 
      dst_filename   = path.expand(rast_coastal_class_file),
      a = 'ID', # attribute to burn
      a_nodata = NA,
      # at = TRUE,
      te = base_te,
      tr = c(500, 500),
      output_Raster = TRUE
    )
  })

  ### now clip coastal zone raster to only intertidal
  values(rast_coastal_class)[is.na(values(rast_zone_intertidal))] <- NA

  ### Now to break down the coastal classes by type.
  # * `coastalclasses` will be determined according to the rule from field `ID`:
  #     * Initial digit (2) is unused?; delete
  #     * Next two digits (0 - 34) denote the coastal class according to
  #         http://alaskafisheries.noaa.gov/mapping/DataDictionary/Common/ShoreType.htm
  #     * final one or two digits represents geographic region; delete
  
  ### First, ditch trailing digit for five-digit values (two-digit regions)
  values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                             values(rast_coastal_class) > 10000] <- 
    floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class)) & 
                                     values(rast_coastal_class) > 10000]/10)
  ### Then, ditch trailing digit for all values
  values(rast_coastal_class)[!is.na(values(rast_coastal_class))] <- 
    floor(values(rast_coastal_class)[!is.na(values(rast_coastal_class))]/10)
  ### Then, subtract 200 to ditch the leading value
  rast_coastal_class <- rast_coastal_class - 200

  writeRaster(rast_coastal_class, rast_coastal_class_file, overwrite = TRUE)
  
  remove(rast_coastal_class) # clean up memory

} else {
  message('Coastal class raster already exists: ', rast_coastal_class_file)
}

```


``` {r create_rocky_intertidal_raster, echo = FALSE}
### At some point, need to mask with land layer.  Coastal zone edges inland of intertidal.
### Write up issue with different layers, and possible inputs.
### Does each cell get just one value?
### * if so: how to prioritize layers?
### * if not: what determines which layers get used where? (based on pressure)
### * Which sublayers inform the higher-level habitat layers.

rast_rocky_intertidal_file <- file.path(dir_rast, 'rast_rocky_intertidal.tif')

if(!exists(rast_rocky_intertidal_file)) {
  ### Set up a list of file locations to be loaded as polygons.  First line
  ### determines which layers to read in and load.
  tmp_hab_lyrs  <- hab_lyrs %>% 
    filter(category == 'rocky intertidal' & load_layer == TRUE)
  
  ### Set up temp directory to store rasters; we'll save the completed raster then get rid of these.
  dir_tmp <- file.path(dir_rast, 'tmp')
  dir.create(dir_tmp)
  
  for (i in 1:nrow(tmp_hab_lyrs)) { # i = 1
    message('Reading layer: ', tmp_hab_lyrs$layer_name[i])
    tmp_shp <- readOGR(dsn   = file.path(dir_anx, 'data', tmp_hab_lyrs$dir[i]),
                                 layer = tmp_hab_lyrs$layer_name[i], 
                                 stringsAsFactors = FALSE)
    if(tmp_hab_lyrs$layer_type[i] %in% c('line', 'point')) {
      message(sprintf('Buffering a %s layer: %s', 
                      tmp_hab_lyrs$layer_type[i], tmp_hab_lyrs$layer_name[i]))
      system.time({
        tmp_poly <- rgeos::gBuffer(tmp_shp, 
                                   byid     = TRUE,
                                   width    = 1500, ### extra wide to prevent gaps
                                   capStyle = 'FLAT')
      })
    } else {
      tmp_poly <- tmp_shp ### shp is already a polygon...
    }
    ### write poly to a temp file for the gdal_rasterize to access.
    writePolyShape(tmp_poly, file.path(dir_tmp, sprintf('tmp_poly%s', i)))
  }
  
  
  tmp_rast_list <- list() ### initialize empty list to store rasters
  base_te <- c(rast_base@extent[1], rast_base@extent[3], rast_base@extent[2], rast_base@extent[4])
  library(gdalUtils)
  
  for (i in 1:nrow(tmp_hab_lyrs)) {
    message(sprintf('Rasterizing temporary polygon %s of %s', i, nrow(tmp_hab_lyrs)))
    system.time({
      tmp_rast_list[[i]] <- gdal_rasterize(
        src_datasource = path.expand(file.path(dir_tmp, sprintf('tmp_poly%s.shp', i))), 
        dst_filename   = path.expand(file.path(dir_tmp, sprintf('tmp_rast%s.shp', i))),
        a = 'ID', # attribute to burn
        a_nodata = NA,
        # at = TRUE,
        te = base_te,
        tr = c(500, 500),
        output_Raster = TRUE
      )
    })
  }
  
  names(tmp_rast_list) <- tmp_hab_lyrs$layer_name
  
  ### And now, process these beeyatches
  ### * sum them, with na.rm = TRUE
  ### * set non-NA values equal to 1 (or whatevs)
  ### * clip to intertidal raster
  rast_coastal_class <- raster(rast_coastal_class_file) ### load coastal_class; need to filter to appropriate cells
  values(rast_coastal_class)[values(rast_coastal_class) %in% c(1:10, 21:23)] <- 1
  
  tmp_rast_list[[i+1]] <- rast_coastal_class
  ### then add to tmp_rast_list; then brick it, then sum it, then turn 0 into NA, then clip, then save.
  tmp_rast_brick <- stack(tmp_rast_list)
  tmp_rast_total <- sum(tmp_rast_brick, na.rm = TRUE)
  
  values(tmp_rast_total)[values(tmp_rast_total) == 0] <- NA
  values(tmp_rast_total)[!is.na(values(tmp_rast_total))] <- 1
  
  rast_zone_intertidal <- raster(rast_zone_intertidal_file)
  values(tmp_rast_total)[is.na(values(rast_zone_intertidal))] <- NA

  plot_raster(tmp_rast_total)
  writeRaster(tmp_rast_total, rast_rocky_intertidal_file, overwrite = TRUE)
}

```


``` {r child = file.path(dir_git, 'src/templates/ohibc_prov_ftr.Rmd'), eval = FALSE}
```
