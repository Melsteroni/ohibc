---
title: 'OHIBC: data_prep_howesound.Rmd'
author: "*Compiled on `r date()` by `r Sys.info()['user']`*"
output: 
  html_document:
    toc: true
    number_sections: true
    theme: cerulean
    highlight: haddock
    includes: 
      in_header: '~/github/ohibc/src/templates/ohibc_hdr1.html'
  pdf_document:
    toc: true
---

``` {r setup, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(fig.width = 6, fig.height = 4, fig.path = 'Figs/',
                      echo = FALSE, message = FALSE, warning = FALSE)

library(raster)
library(rgdal)
library(rgeos)

source('~/github/ohibc/src/R/common.R')  ### an OHIBC specific version of common.R

dir_git     <- path.expand('~/github/ohibc')
dir_spatial <- file.path(dir_git, 'prep/spatial')  ### github: general buffer region shapefiles
dir_anx     <- file.path(dir_M, 'git-annex/bcprep')

### goal specific folders and info
goal      <- 'hab'
scenario  <- 'v2016'
dir_goal  <- file.path(dir_git, 'prep', goal, scenario)
dir_goal_anx <- file.path(dir_anx, goal, scenario)

### provenance tracking
library(provRmd); prov_setup()

### support scripts
source(file.path(dir_git, 'src/R/rast_tools.R')) 
  ### gdal_rast2, plotting

### set up the default BC projection to be BC Albers
p4s_bcalb <- c('bcalb' = '+init=epsg:3005')


```

# Summary

Clip existing habitat layers (salt marsh/forest raster, salt marsh and seagrass polygons) for HAB, CP goals for Howe Sound assessment.  

***

# Data Sources

* Seagrass polygons
* Saltmarsh polygons
* Land cover raster 1990-2000-2010
* Exposure polylines
* Coastal class polylines
* Elevation raster
* Population raster

***
  
# Methods

Define extents for Howe Sound in BC Albers projection.

``` {r set up the extents for Howe Sound}
ext_howe <- extent(c(1170000, 1210000, 470000, 530000))
```

Crop region rasters (at 500 m resolution) to Howe Sound extents, then use these to process layers:

* crop exposure polylines and coastal class polylines
    * identify appropriate exposure and coastal classes and rank from low to high (0 to 1) in terms of vulnerability
    * buffer out to (2 km? cap ends?)
    * raster::rasterize using the mean function
* reproject elevation raster and population raster (most recent year, just for weighting) to region raster parameters
* crop land cover raster to region raster extents

## Prepare rasters

``` {r prep region rasters}

rast_base <- raster(file.path(dir_spatial, 'raster/ohibc_rgn_raster_500m.tif')) %>%
  crop(ext_howe)

rast_rgn      <- gdal_rast2(src = file.path(dir_spatial, layer = 'howe_sound_rgn'),
                                 rast_base = rast_base,
                                 dst = file.path(dir_goal, 'tif/howe_rgn.tif'),
                                 value = 'id',
                                 override_p4s = TRUE)
rast_inland   <- gdal_rast2(src = file.path(dir_spatial, layer = 'howe_sound_inland_2km'),
                                 rast_base = rast_base,
                                 dst = file.path(dir_goal, 'tif/howe_inland_2km.tif'),
                                 value = 'rgn_id',
                                 override_p4s = TRUE)
rast_offshore <- gdal_rast2(src = file.path(dir_spatial, layer = 'howe_sound_offshore_3nm'),
                                 rast_base = rast_base,
                                 dst = file.path(dir_goal, 'tif/howe_offshore_3nm.tif'),
                                 value = 'rgn_id',
                                 override_p4s = TRUE)

### NOTE: need to get rid of the finger in the upper left.

```

``` {r prep pop and elev rasters}

topo_rast_file  <- file.path(dir_goal, 'tif/howe_topo.tif')
pdens_rast_file <- file.path(dir_goal, 'tif/howe_pdens.tif')

if(!file.exists(topo_rast_file) | !file.exists(pdens_rast_file)) {
  message('Creating files: \n  ', paste(c(topo_rast_file, pdens_rast_file), collapse = '\n  '))

  ### Gridded Pop of the World raster at Mazu: 
  ###   git-annex/globalprep/_raw_data/CIESEandCIAT_population/d2015
  
  # pop_gl <- raster(file.path(dir_anx, '../globalprep/_raw_data/CIESEandCIAT_population/d2015/pop_count_data', 'glp15ag.asc'))
  # crs(pop_gl) <- '+init=epsg:4326'
  # rast_pop   <- projectRaster(pop_gl, rast_rgn, method = 'ngb')
  
  pop_dens_gl <- raster(file.path(dir_anx, 
                                  '../globalprep/_raw_data/CIESEandCIAT_population', 
                                  'd2015/pop_density_data/glfedens15/glds15ag',
                                  'dblbnd.adf'))
  crs(pop_dens_gl) <- '+init=epsg:4326'
  rast_pdens <- projectRaster(pop_dens_gl, rast_rgn) ### NOTE: uses bilinear
  writeRaster(rast_pdens, pdens_rast_file, overwrite = TRUE)  
  
  ### ETOPO v2 in Mazu:
  ### git-annex/bcprep/_raw_data/bathymetry/ETOPO2v2_bathymetry
  etopo <- raster(file.path(dir_anx, '_raw_data/bathymetry/ETOPO2v2_bathymetry',
                            'ETOPO2v2c.tif'))
  ### add CRS and extent info:
  crs(etopo) <- '+init=epsg:4326'
  extent(etopo) <- c(-180, 180, -90, 90)
  
  rast_topo <- projectRaster(etopo, rast_rgn)
  
  writeRaster(rast_topo, topo_rast_file, overwrite = TRUE) 
  
} else {
  
  message('Files exist: \n  ', paste(c(topo_rast_file, pdens_rast_file), collapse = '\n  '))
  git_prov(c(topo_rast_file, pdens_rast_file), filetype = 'output')
  
}


```

## Prepare exposure raster

Because the exposure raster is based off a 2 km buffer from shoreline polylines, it also acts as a masking layer to avoid inland habitats.

``` {r prep_exposure_raster}

expos_rast_file  <- file.path(dir_goal, 'tif/howe_expos.tif')

if(!file.exists(expos_rast_file)) {
  message('Creating file: \n  ', expos_rast_file)

  dir_bcmca <- file.path(dir_anx, '_raw_data/bcmca/bcmca_eco_set_physical_complete/MarxanData_Physical')
  
  # poly_coastal_class <- readOGR(dir_bcmca, 'BCMCA_ECO_Physical_CoastalClasses_MARXAN') %>%
  #   crop(rast_rgn)
  poly_exposure <- readOGR(dir_bcmca, 'BCMCA_ECO_Physical_Exposure_MARXAN') %>%
    crop(rast_rgn)
  
  poly_exp_2km <- poly_exposure %>%
    gBuffer(width = 2000, byid = TRUE, capStyle = 'FLAT')
  
  ### hunch: third digit is exposure: 
  # 6: Very Exposed
  # 5: Exposed
  # 4: Semi-exposed
  # 3: Semi-protected
  # 2: Protected
  # 1: Very Protected
  
  poly_exp_2km@data <- poly_exp_2km@data %>%
    mutate(exposure = floor((ID - 2400)/10))
  
  rast_expos <- rasterize(poly_exp_2km, rast_rgn, field = 'exposure', fun = 'mean')
  expos_max <- maxValue(rast_expos); expos_min <- 0; # minValue(rast_expos)
  rast_expos <- (rast_expos - expos_min) / (expos_max - expos_min)
  
  rast_expos <- mask(rast_expos, rast_rgn)
  
  writeRaster(rast_expos, expos_rast_file, overwrite = TRUE)
  
} else {
  
  message('File exists: \n  ', expos_rast_file)
  git_prov(expos_rast_file, filetype = 'output')
  
}
```

## Analysis of coastal protection

Coastal protection for seagrass and salt will be mitigated by exposure

Coastal protection for trees/fores will be mitigated by exposure and elevation (0 m = 1.0, 5 m or higher = 0)

Both will be scaled relative to log(pdens + 1)

``` {r process_seagrass_rast}

### load all BC seagrass nutrient pressure rasters; already rescaled
### to 1.1 * max pressure across all BC.
seagrass_years <- c(2002:2013)

stack_seagrass_allbc <- stack(file.path(dir_goal_anx, 'raster', 
                                 sprintf('seagrass_nutr_%s.tif', seagrass_years)))
nutr_ref <- maxValue(stack_seagrass_allbc) %>% max()

### now chop it down to size.
stack_seagrass_howe <- stack_seagrass_allbc %>%
  crop(rast_rgn)

### modify nutr pressures by exposure ratings in Howe Sound; this also masks
### to just the howe sound area of interest.  First reproject the exposure to 100 m:
rast_expos_100m <- raster(file.path(dir_goal, 'tif/howe_expos.tif')) %>%
  projectRaster(stack_seagrass_howe[[1]]) ### NOTE: bilinear

stack_seagrass_expos <- stack_seagrass_howe * rast_expos_100m
  
### now modify by pop density
rast_pdens_log <- raster(file.path(dir_goal, 'tif/howe_pdens.tif')) %>%
  calc(fun = function(x) {log(x + 1)})

rast_pdens_log <- rast_pdens_log/maxValue(rast_pdens_log)

rast_pdens_log_100m <- rast_pdens_log %>%
  projectRaster(stack_seagrass_howe[[1]]) ### NOTE: bilinear

stack_seagrass_expos_pop <- stack_seagrass_expos * rast_pdens_log_100m 

names(stack_seagrass_expos_pop) <- seagrass_years

### create dataframe to average cell values

seagrass_vec <- lapply(as.list(stack_seagrass_expos_pop), 
                FUN = function(x) {
                  mean(values(x), na.rm = TRUE)}) %>%
  setNames(seagrass_years) %>%
  unlist() 

seagrass_df <- data.frame(year = names(seagrass_vec),
                    mean_sg = seagrass_vec,
                    score_sg = 1 - seagrass_vec)

seagrass_df <- seagrass_df %>%
  mutate(sg_area_km2 = sum(!is.na(values(stack_seagrass_expos_pop[[1]]))) * .01)

write_csv(seagrass_df, file.path(dir_goal, 'int/howe_seagrass_status_trend.csv'))

```

Salt Marsh health for status and trend.  For this measure, we will determine rate of salt marsh change within 2 km inland and offshore.  Salt marsh presence will be established using categories 71, 73, and 74 from the Government of Canada 30 m land use rasters for 1990, 2000, and 2010.  

Salt marsh health status is determined by summing the weighted vulnerability value of salt marshes over the whole Howe Sound area.  Vulnerability value is weighted by exposure (0.25 = very protected, 1.0 = semi exposed, categories from BCMCA) and population density (log(ppl/km^2 + 1), then rescaled to highest value = 1).  As saltmarsh is lost, the sum drops; saltmarsh lost in exposed and/or highly populated areas counts as a higher penalty.  The reference point for a score of 1 will be the 1990 salt marsh sum(weighted vulnerability value).

Salt marsh trend will be based on percentage of change from 2000 to 2010 divided across the ten year interval.

``` {r process_saltmarsh_rast}

landuse_files <- c('1990' = file.path(dir_goal_anx, 'raster/land_cover_1990_30m_crop.tif'),
                   '2000' = file.path(dir_goal_anx, 'raster/land_cover_2000_30m_crop.tif'),
                   '2010' = file.path(dir_goal_anx, 'raster/land_cover_2010_30m_crop.tif'))

stack_landuse <- stack(landuse_files) %>%
  crop(rast_rgn)

stack_sm <- filter_rast(stack_landuse, vals = c(71, 73, 74), revalue = 1)

### multiply saltmarsh values by exposure to de-emphasize protective value
### near already protected areas
rast_expos_30m <- raster(file.path(dir_goal, 'tif/howe_expos.tif')) %>%
  projectRaster(stack_sm) ### NOTE: bilinear

stack_sm_expos <- stack_sm * rast_expos_30m

### multiply by rescaled log population density to emphasize 
### protection value near high population densities
rast_pdens_log <- raster(file.path(dir_goal, 'tif/howe_pdens.tif')) %>%
  calc(fun = function(x) {log(x + 1)})

rast_pdens_log <- rast_pdens_log/maxValue(rast_pdens_log)

rast_pdens_log_30m <- rast_pdens_log %>%
  projectRaster(stack_sm) ### NOTE: bilinear

stack_sm_expos_pop <- stack_sm_expos * rast_pdens_log_30m

### write final rasters
sm_rast_files <- file.path(dir_goal_anx, sprintf('raster/howe_sound_sm_%s.tif', c(1990, 2000, 2010)))
writeRaster(stack_sm_expos_pop, filename = sm_rast_files, bylayer = TRUE, overwrite = TRUE)

### create dataframe to sum cell values

saltmarsh_df <- data.frame(year = c(1990, 2000, 2010))

for (i in 1:3) {
  saltmarsh_df$sum_sm[i] <- values(stack_sm_expos_pop[[i]]) %>%
    sum(na.rm = TRUE)
  saltmarsh_df$area_sm_km2[i] <- sum(!is.na(values(stack_sm_expos_pop[[i]]))) * (.03 * .03)
}

saltmarsh_df <- saltmarsh_df %>%
  mutate(sm_score = sum_sm / first(sum_sm),
         sm_loss  = (sm_score - lag(sm_score, 1)) / lag(sm_score, 1),
         sm_trend = sm_loss / 10)

write_csv(saltmarsh_df, file.path(dir_goal, 'int/howe_saltmarsh_status_trend.csv'))


```

Coastal forests are calculated similar to salt marsh; vulnerability factors include exposure and population, and in addition, elevation is considered.  Anything at sea level is vulnerable (1) up to an elevation of 5 m (vulnerability = 0).  This 5 m value is taken from InVEST, due to the inundation/storm surge from an extreme event.

``` {r process_coastal_forest_rast}

# landuse_files <- c('1990' = file.path(dir_goal_anx, 'raster/land_cover_1990_30m_crop.tif'),
#                    '2000' = file.path(dir_goal_anx, 'raster/land_cover_2000_30m_crop.tif'),
#                    '2010' = file.path(dir_goal_anx, 'raster/land_cover_2010_30m_crop.tif'))
# 
# stack_landuse <- stack(landuse_files) %>%
#   crop(rast_rgn)

stack_cf <- filter_rast(stack_landuse, vals = c(41, 42, 45, 46), revalue = 1)

### multiply saltmarsh values by exposure to de-emphasize protective value
### near already protected areas
# rast_expos_30m <- raster(file.path(dir_goal, 'tif/howe_expos.tif')) %>%
#   projectRaster(stack_cf) ### NOTE: bilinear

stack_cf_expos <- stack_cf * rast_expos_30m

### multiply by rescaled log population density to emphasize 
### protection value near high population densities
# rast_pdens_log <- raster(file.path(dir_goal, 'tif/howe_pdens.tif')) %>%
#   calc(fun = function(x) {log(x + 1)})
# 
# rast_pdens_log <- rast_pdens_log/maxValue(rast_pdens_log)
# 
# rast_pdens_log_30m <- rast_pdens_log %>%
#   projectRaster(stack_cf) ### NOTE: bilinear

stack_cf_expos_pop <- stack_cf_expos * rast_pdens_log_30m

### multiply by elevation vulnerability; areas above 5 m
### in elevation are not vulnerable to typical storm surge (from InVEST)
elev_lim <- 5
rast_elev_30m <- raster(file.path(dir_goal, 'tif/howe_topo.tif')) %>%
  projectRaster(stack_cf) %>%
  calc(fun = function(x) {ifelse(x <= 0, NA,
                            ifelse(x > elev_lim, 0,
                              (1 - x/elev_lim))
                            )
                          })

stack_cf_expos_pop_elev <- stack_cf_expos_pop * rast_elev_30m

### write final rasters
cf_rast_files <- file.path(dir_goal_anx, sprintf('raster/howe_sound_cf_%s.tif', c(1990, 2000, 2010)))
writeRaster(stack_cf_expos_pop_elev, filename = cf_rast_files, bylayer = TRUE, overwrite = TRUE)

### create dataframe to sum cell values

coastalforest_df <- data.frame(year = c(1990, 2000, 2010))

for (i in 1:3) {
  coastalforest_df$sum_cf[i] <- values(stack_cf_expos_pop_elev[[i]]) %>%
    sum(na.rm = TRUE)
  coastalforest_df$area_cf_km2[i] <- sum(!is.na(values(stack_cf_expos_pop_elev[[i]]))) * (.03 * .03)
  coastalforest_df$area_nonzero_cf_km2[i] <- sum(values(stack_cf_expos_pop_elev[[i]]) != 0, na.rm = TRUE) * (.03 * .03)
}

coastalforest_df <- coastalforest_df %>%
  mutate(cf_score = sum_cf / first(sum_cf),
         cf_loss  = (cf_score - lag(cf_score, 1)) / lag(cf_score, 1),
         cf_trend = cf_loss / 10)

write_csv(coastalforest_df, file.path(dir_goal, 'int/howe_forest_status_trend.csv'))

```

## results

### seagrass

`r DT::datatable(seagrass_df)`

### saltmarsh

`r DT::datatable(saltmarsh_df)`

### coastal forests

`r DT::datatable(coastalforest_df)`


***

``` {r prov_footer, results = 'asis'}
prov_wrapup()
```

